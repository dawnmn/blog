**慢查询日志**
```
# 配置
vim /etc/my.cnf

slow_query_log=ON
long_query_time=2

# 查看 包括慢日志路径
show variables like '%slow%';
+---------------------------+---------------------------------+
| Variable_name             | Value                           |
+---------------------------+---------------------------------+
| log_slow_admin_statements | OFF                             |
| log_slow_slave_statements | OFF                             |
| slow_launch_time          | 2                               |
| slow_query_log            | ON                              |
| slow_query_log_file       | /var/lib/mysql/dbname-slow.log |
+---------------------------+---------------------------------+
show variables like "%long%";

```

 **variables & global status**
服务器启动至今的运行数据（重启刷新）
```
# 慢查询
show variables like '%slow%';
show global status like '%slow%';
# 最大连接数
show variables like 'max_connections';
show global status like 'max_used_connections';
# 临时表
show global status like 'created_tmp%';
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Created_tmp_disk_tables | 75512  |
| Created_tmp_files       | 60     |
| Created_tmp_tables      | 365050 |
+-------------------------+--------+
Created_tmp_disk_tables / Created_tmp_tables * 100% ＝ 99% （理想值<= 25%）


# 排序
show variables like 'max_length_for_sort_data';
show variables like 'sort_buffer_size';

排序过程：
1. 根据索引或者全表扫描，按照过滤条件获得需要查询的排序字段值与[rowID/用户需要返回的字段]组成键值对，并存入sort buffer中。
2. 如果sort buffer内存小于这些键值对的内存，就只在内存中排序，否则就需要创建临时文件。
3. 如果不指定order by，mysql会以“最快”的速度进行排序，因此结果是不确定、变化的。

优化排序的方式：
* 排序和查询的字段尽量少。只查询你用到的字段，不要使用select *；使用Limit查询必要的行数据；
* 要排序或者查询的字段，尽量不要用不确定字符函数，避免MySQL直接分配max_sort_length，导致sort buffer空间不足。
* 使用索引来优化或者避免排序。
* 增加sort_buffer_size大小，避免磁盘排序。
* 加大max_length_for_sort_data大小，避免选择老式的算法。
```


