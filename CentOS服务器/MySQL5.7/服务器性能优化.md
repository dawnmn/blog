**慢查询日志**
```
# 配置
vim /etc/my.cnf

slow_query_log=ON
long_query_time=2

# 查看 包括慢日志路径
show variables like '%slow%';
+---------------------------+---------------------------------+
| Variable_name             | Value                           |
+---------------------------+---------------------------------+
| log_slow_admin_statements | OFF                             |
| log_slow_slave_statements | OFF                             |
| slow_launch_time          | 2                               |
| slow_query_log            | ON                              |
| slow_query_log_file       | /var/lib/mysql/dbname-slow.log |
+---------------------------+---------------------------------+
show variables like "%long%";

```

 **variables & global status**
服务器启动至今的运行数据（重启刷新）
```
# 慢查询
show variables like '%slow%';
show global status like '%slow%';
# 最大连接数
show variables like 'max_connections';
show global status like 'max_used_connections';
# 临时表
show global status like 'created_tmp%';
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Created_tmp_disk_tables | 75512  |
| Created_tmp_files       | 60     |
| Created_tmp_tables      | 365050 |
+-------------------------+--------+
Created_tmp_disk_tables / Created_tmp_tables * 100% ＝ 99% （理想值<= 25%）


# 排序
show variables like 'max_length_for_sort_data';
show variables like 'sort_buffer_size';

排序过程：
1. 根据索引或者全表扫描，按照过滤条件获得需要查询的排序字段值与[rowID/用户需要返回的字段]组成键值对，并存入sort buffer中。
2. 如果sort buffer内存小于这些键值对的内存，就只在内存中排序，否则就需要创建临时文件。
3. 如果不指定order by，mysql会以“最快”的速度进行排序，因此结果是不确定、变化的。

优化排序的方式：
* 排序和查询的字段尽量少。只查询你用到的字段，不要使用select *；使用Limit查询必要的行数据；
* 要排序或者查询的字段，尽量不要用不确定字符函数，避免MySQL直接分配max_sort_length，导致sort buffer空间不足。
* 使用索引来优化或者避免排序。
* 增加sort_buffer_size大小，避免磁盘排序。
* 加大max_length_for_sort_data大小，避免选择老式的算法。
```

**数据类型**
更小的通常更好，不仅能节省磁盘，更能够节省内存。
整数类型的unsigned属性可以使正数的上限提高一倍。
IPv4实际上是32位无符号整数，可以使用MySQL的inet_aton()、inet_ntoa()转换。
MySQL的NULL读写都对应PHP的NULL。
更快地读，更慢地写：为了提升读查询的速度，经常需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表，这对于设计高性能数据库是常见的技巧。

**索引**
索引优化应该是对查询优化最有效的手段了。“最优”的索引有时候比“好的”索引性能要好几个数量级，创建一个真正“最优”的索引经常需要重写查询。
覆盖索引：select的数据列只用从索引中就能够取得。
回表：从表中查询列值。

**查询优化**
最简单衡量查询优化开销的的三个指标：
* 响应时间
* 扫描的行数
* 返回的行数

慢查询方法：
1 访问了太多的行或列
2 扫描的行数和返回的行数，如果扫描的行数远大于返回的行数，可以通过使用索引、改变库表结构、分解复杂的查询等方式。
