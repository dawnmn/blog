
**允许远程访问**
```
use mysql;
update user set host = '%' where user = 'root' ;
flush privileges;
```
**innodb事务中加锁**
```
select * from table where ? lock in share mode;
select * from table where ? for update;
```
**连接数**
```
# 查看最大连接数
show variables like '%max_connection%';
# 重新设置最大连接数
set global max_connections=1000;
# 查看连接数
show status like  'Threads%';
```
**数据库备份与还原**
```
#备份
mysqldump -uroot -pYourPass -R --triggers --master-data=2 --single-transaction --databases db_name > /var/tmp/db_name.sql

#还原
mysql -u root -pYourPass < /var/tmp/db_name.sql
```
**查询某个用户的排名**
需要修改customer_data、costs、customer_id。

```
select u.rowNo from (
  select customer_id,(@rowNum:=@rowNum+1) as rowNo from 
  customer_data, (select (@rowNum :=0)) b 
  order by customer_data.costs desc 
) u 
where u.customer_id=634
```
**同一MySQL实例下的跨库**
表前带上数据库名。

```
SELECT sbtest.sbtest1.id,sbtest.sbtest1.k,customer.id,customer.nickname
from customer
JOIN sbtest.sbtest1 on sbtest.sbtest1.id=customer.id
WHERE customer.id < 30
```
**不同MySQL实例下的跨库**
仅供参考，没有实用性。

```
show engines;
```
如果有FEDERATED引擎，但Support是NO，说明你的mysql安装了这个引擎，但没启用，去my.cnf文件末添加一行  federated  ，重启mysql即可。
在机器A的数据库A中创建与机器B的数据库B中结构完全相同的表B，通过federated引擎的建表方式：
```
CREATE TABLE `table_name`(......) ENGINE =FEDERATED CONNECTION='mysql://[username]:[password]@[location]:[port]/[db-name]/[table-name]'
```
相当于只是在数据库A中创建了表B的一个快捷方式，不支持事务，不支持表结构修改。





**快速导入导出大表**
```
#导出表数据
select * 
from table_name
into outfile '/var/tmp/table_name.txt'
CHARACTER SET utf8
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
 
#导入表数据
load data INFILE '/var/tmp/table_name.txt'
into TABLE table_name
CHARACTER SET utf8
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
```





**持久化策略配置**
双1模式（安全性）和0 2模式（高性能）
| 参数 | 可选值 | 含义 |
| --- | --- | --- |
| sync\_binlog | 0 | binlog刷盘持久化由操作系统完成，性能好，存在丢失binlog的风险 |
| sync\_binlog | 1 | 事务提交后刷盘持久化，最安全 |
| sync\_binlog | N | 在每N个事务提交后进行刷盘持久化 |
| innodb\_flush\_log\_at\_trx\_commit | 0 | 每秒钟写redo log 并刷盘持久化 |
| innodb\_flush\_log\_at\_trx\_commit | 1 | 事务提交后写redo log 并刷盘持久化，最安全 |
| innodb\_flush\_log\_at\_trx\_commit | 2 | 事务提交后写redo log , 每秒刷盘持久化 |

**SQL逻辑查询语句执行顺序**
```
(7)     SELECT 
(8)     DISTINCT <select_list>
(1)     FROM <left_table>
(3)     <join_type> JOIN <right_table>
(2)     ON <join_condition>
(4)     WHERE <where_condition>
(5)     GROUP BY <group_by_list>
(6)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```
**常用指令**
```
select version();

describe tablename;
show create table tablename;

Flush tables with read lock;
# 重建表
alter table tablename engine=innodb;
# 查看连接的进程状态数据
show processlist;
```
**kill命令**
```
kill query thread_id;
kill connection thread_id;
```
**存在更新，不存在插入**
支持批量
```
INSERT INTO TY_FAULT_LIST (`PROBE_ID`,`TASK_ID`,`IP`,`PORT`,`TYPE`,`STATUS`,`FIRST_TIME`,`LAST_TIME`,`COUNT`) VALUES (xxxxx) ON DUPLICATE KEY UPDATE `FIRST_TIME`=VALUES(`FIRST_TIME`),`LAST_TIME`=VALUES(`LAST_TIME`),`COUNT`=VALUES(`COUNT`)
```


