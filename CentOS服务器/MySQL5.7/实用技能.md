
**允许远程访问**
```
use mysql;
update user set host = '%' where user = 'root' ;
flush privileges;
```
**同一MySQL实例下的跨库**
```
SELECT sbtest.sbtest1.id,sbtest.sbtest1.k,customer.id,customer.nickname
from customer
JOIN sbtest.sbtest1 on sbtest.sbtest1.id=customer.id
WHERE customer.id < 30
```
**不同MySQL实例下的跨库**
```
show engines;
```
如果有FEDERATED引擎，但Support是NO，说明你的mysql安装了这个引擎，但没启用，去my.cnf文件末添加一行  federated  ，重启mysql即可。
在机器A的数据库A中创建与机器B的数据库B中结构完全相同的表B，通过federated引擎的建表方式：
```
CREATE TABLE `table_name`(......) ENGINE =FEDERATED CONNECTION='mysql://[username]:[password]@[location]:[port]/[db-name]/[table-name]'
```
相当于只是在数据库A中创建了表B的一个快捷方式，不支持事务，不支持表结构修改。

**配置utf8mb4**
```
vim /etc/my.cnf

[client] 
default-character-set = utf8mb4 
[mysql] 
default-character-set = utf8mb4 
[mysqld] 
character-set-client-handshake = FALSE 
character-set-server = utf8mb4 
collation-server = utf8mb4_unicode_ci
init_connect='SET NAMES utf8mb4'

重启mysqld，检查变量：
SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%';
```

**获取排名**
```
select u.rowNo from (
select customer_id,(@rowNum:=@rowNum+1) as rowNo from 
customer_data, (select (@rowNum :=0)) b 
order by customer_data.costs desc ) u 
where u.customer_id=634
```

**快速导入导出大表**
```
#导出表数据
select * 
from table_name
into outfile '/var/tmp/table_name.txt'
CHARACTER SET utf8
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
 
#导入表数据
load data INFILE '/var/tmp/table_name.txt'
into TABLE table_name
CHARACTER SET utf8
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
```

**数据库备份与还原**
```
#备份
mysqldump -u root -pYourPassword db_name > /var/tmp/db_name.sql

#还原
mysql -u root -pYourPassword db_name < /var/tmp/db_name.sql
```

**innodb事务中加锁**
```
select * from table where ? lock in share mode;
select * from table where ? for update;
```

**持久化策略配置**
双1模式（安全性）和0 2模式（高性能）
| 参数 | 可选值 | 含义 |
| --- | --- | --- |
| sync\_binlog | 0 | binlog刷盘持久化由操作系统完成，性能好，存在丢失binlog的风险 |
| sync\_binlog | 1 | 事务提交后刷盘持久化，最安全 |
| sync\_binlog | N | 在每N个事务提交后进行刷盘持久化 |
| innodb\_flush\_log\_at\_trx\_commit | 0 | 每秒钟写redo log 并刷盘持久化 |
| innodb\_flush\_log\_at\_trx\_commit | 1 | 事务提交后写redo log 并刷盘持久化，最安全 |
| innodb\_flush\_log\_at\_trx\_commit | 2 | 事务提交后写redo log , 每秒刷盘持久化 |

**SQL逻辑查询语句执行顺序**
```
(7)     SELECT 
(8)     DISTINCT <select_list>
(1)     FROM <left_table>
(3)     <join_type> JOIN <right_table>
(2)     ON <join_condition>
(4)     WHERE <where_condition>
(5)     GROUP BY <group_by_list>
(6)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```
**连接数**
```
# 查看最大连接数
show variables like '%max_connection%';
# 重新设置最大连接数
set global max_connections=1000;
# 查看连接数
show status like  'Threads%';
```
