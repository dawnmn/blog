#### **跨库联表查询**
**同一MySQL实例下的跨库**
```
SELECT sbtest.sbtest1.id,sbtest.sbtest1.k,customer.id,customer.nickname
from customer
JOIN sbtest.sbtest1 on sbtest.sbtest1.id=customer.id
WHERE customer.id < 30
```
**不同MySQL实例下的跨库**
```
show engines;
```
如果有FEDERATED引擎，但Support是NO，说明你的mysql安装了这个引擎，但没启用，去my.cnf文件末添加一行  federated  ，重启mysql即可。
在机器A的数据库A中创建与机器B的数据库B中结构完全相同的表B，通过federated引擎的建表方式：
```
CREATE TABLE `table_name`(......) ENGINE =FEDERATED CONNECTION='mysql://[username]:[password]@[location]:[port]/[db-name]/[table-name]'
```
相当于只是在数据库A中创建了表B的一个快捷方式，不支持事务，不支持表结构修改。

#### **配置utf8mb4**
```
vim /etc/my.cnf

[client] 
default-character-set = utf8mb4 
[mysql] 
default-character-set = utf8mb4 
[mysqld] 
character-set-client-handshake = FALSE 
character-set-server = utf8mb4 
collation-server = utf8mb4_unicode_ci
init_connect='SET NAMES utf8mb4'

重启mysqld，检查变量：
SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%';
```

#### **获取排名**
```
select u.rowNo from (
select customer_id,(@rowNum:=@rowNum+1) as rowNo from 
customer_data, (select (@rowNum :=0)) b 
order by customer_data.costs desc ) u 
where u.customer_id=634
```

#### **快速导入导出大表**
```
#导出表数据
select * 
from table_name
into outfile '/var/tmp/table_name.txt'
CHARACTER SET utf8
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
 
#导入表数据
load data INFILE '/var/tmp/table_name.txt'
into TABLE table_name
CHARACTER SET utf8
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
```

#### **数据库备份与还原**
```
#备份
mysqldump -u root -pYourPassword db_name > /var/tmp/db_name.sql

#还原
mysql -u root -pYourPassword db_name < /var/tmp/db_name.sql
```

#### **innodb事务中加锁**
```
select * from table where ? lock in share mode;
select * from table where ? for update;
```

#### **持久化策略配置**
| 参数 | 可选值 | 含义 |
| --- | --- | --- |
| sync\_binlog | 0 | binlog刷盘持久化由操作系统完成，性能好，存在丢失binlog的风险 |
| sync\_binlog | 1 | 事务提交后刷盘持久化，最安全 |
| sync\_binlog | N | 在每N个事务提交后进行刷盘持久化 |
| innodb\_flush\_log\_at\_trx\_commit | 0 | 每秒钟写redo log 并刷盘持久化 |
| innodb\_flush\_log\_at\_trx\_commit | 1 | 事务提交后写redo log 并刷盘持久化，最安全 |
| innodb\_flush\_log\_at\_trx\_commit | 2 | 事务提交后写redo log , 每秒刷盘持久化 |
