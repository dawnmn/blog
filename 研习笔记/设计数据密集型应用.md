**MapReduce**
编程模型的原理是：利用一个输入 key/value 集合来产生一个输出的 key/value 集合。MapReduce 库的用户用两个函数表达这个计算：Map 和 Reduce。
用户自定义的 Map 函数接受一个输入的 key/value 值，然后产生一个中间 key/value 值的集合。MapReduce 库把所有具有相同中间 key 值 I 的中间 value 值集合在一起后传递给 reduce 函数。
用户自定义的 Reduce 函数接受一个中间 key 的值 I 和相关的一个 value 值的集合。Reduce 函数合并这些value 值，形成一个较小的 value 值的集合。一般的，每次 Reduce 函数调用只产生 0 或 1 个输出 value 值。通常我们通过一个迭代器把中间 value 值提供给 Reduce 函数，这样我们就可以处理无法全部放入内存中的大量的 value 值的集合。


计算 URL 访问频率：Map 函数处理日志中 web 页面请求的记录，然后输出(URL,1)。Reduce 函数把相同URL 的 value 值都累加起来，产生(URL,记录总数)结果。
![](../images/MapReduce执行概述.png)


当用户调用 MapReduce 函数时，将发生下面的一系列动作：
1. 用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。
2. 这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配给一个空闲的 worker。
3. 被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key/value pair，并缓存在内存中。
4. 缓存中的 key/value pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给Reduce worker。
5. 当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 Map worker 所在主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。
6. Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 程序将这个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。
7. 当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里的对MapReduce 调用才返回。

应用场景：在分布式环境中处理海量数据，Hadoop。

```
现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。

据报道称，硬盘的平均无故障时间（MTTF, mean time to failure）约为10到50年。因此从数学期望上讲，在拥有10000个磁盘的存储集群上，平均每天会有1个磁盘出故障。
运维配置错误是导致服务中断的首要原因，而硬件故障（服务器或网络）仅导致了10-25％的服务中断。

精心设计的抽象、API和管理后台使做对事情更容易，搞砸事情更困难。但如果接口限制太多，人们就会忽略它们的好处而想办法绕开。很难正确把握这种微妙的平衡。
提供一个功能齐全的非生产环境沙箱（sandbox），使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。
允许从人为错误中简单快速地恢复以最大限度地减少失效情况带来的影响。如：快速回滚配置变更，分批发布新代码。

推特发布推文、查阅推文的解决方案，缓存代价与查询代价的平衡：
1 普通用户维护推文查询缓存。
2 海量粉丝的用户的推文会被实时查询。

达标率：p95、p99、p999，意味着95％、99％、99.9％的达标率。

用于消除额外复杂度的最好工具之一是抽象，如何找到合适的抽象：
从计算机领域常见的抽象中找。
从日常生活中常接触的概念找。

0 1的载体：电光磁

平均响应时间：不能反映实际有多少用户经历了这个延迟。
中位数：一半的人小于这个值，一半的人大于这个值。
统计图：最好的方式是看折线图。
头部阻塞：只要有少量缓慢的请求就能阻碍后续请求的处理，即使后续请求在服务器上处理的非常迅速。

吞吐量：单位时间能处理多少个请求、或者多少kb数据。
简单易懂的系统通常比复杂系统更容易修改。

文档型数据库可用实现1对多的关系（将嵌套数据放在父节点中），但是难以实现多对多。

appendOnly型日志的索引方式：内存保存key和值在日志文件中的偏移量。

向后兼容：新版本的系统可以接受旧版本的数据（包括线上代码）。
向前兼容：旧版本的系统可以接受新版本的数据。

json不支持二进制数据，可以用Base64编码将二进制数据转换成文本（缺点，增加1/3的数据大小）。
protocol buffer
数据压缩：
1 Protocol Buffer 序列化采用Varint、Zigzag（负数、大整数较多时应当使用sint32/sint64数据类型）方法，压缩整数。对浮点型数字、字符串不做压缩。
2 若optional、repeated字段没有被设置字段值，不进行序列化。
3 序列化的过程都是二进制的位移，速度非常快。以TLV（tag-length-value或tag-value，key=tag=(field_number << 3) | wire_type）的结构存储二进制数据，摆脱了JSON中的{ } " : ,分隔符。

chrome浏览器进程：浏览器进程、渲染进程、GPU进程、网络进程、每个页面和插件各自的进程。
前端请求：
jquery的jax基于XMLHttpRequest。
vue的axoisXMLHttpRequest和promise。
es6的fetch实现了XMLHttpRequest。

REST似乎是公共API（各类系统的应用接口）的主要风格。 
RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内。

热备份：系统处于正常运转状态下的备份。
最终一致性：从节点数据落后于主节点，但在一个不确定的时间后会跟上主节点。

服务发现：解决如何确定分布于网络中不同机器上的服务的具体坐标（全限定名+端口号）的问题。
1 服务的注册。服务启动的时候，它应该通过某些形式（如调用 API、产生事件消息、在 ZooKeeper/Etcd 的指定位置记录、存入数据库）将自己的坐标信息通知到服务注册中心。
2 服务的维护。服务中心通过多种协议（HTTP、TCP 等）、多种方式（长连接、心跳、探针、进程状态等）去监控服务，剔除异常的服务。
3 服务的发现。服务中心将消费者调用的符号转换成服务的实际坐标。

从不可靠的组件构建可靠的系统（有限的可靠），示例：TCP协议、云服务器。
```
