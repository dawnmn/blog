mysql是由c和c++编写的。
mysql服务器逻辑架构:
服务层：处理客户端连接、sql解析和优化（重写sql、表的读取顺序、索引选择等）、存储过程、触发器等。
存储引擎层：数据存储和提取。
mysql服务层和存储引擎层都有锁。

用null而不是自己伪造零值。

并发控制：共享锁（读锁）、排它锁（写锁）,获取锁、检查是否解锁、释放锁都会耗费资源。锁策略：在锁的开销和数据安全性之间的平衡。锁粒度：表锁（MySQL服务器层）和行锁（Innodb层，并发处理最好，开销最大）
读锁：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。
写锁：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。
范围锁: 对于某个范围直接加排他锁，在这个范围内的数据不能被写入。
从业务层面去减少锁和死锁。
事务：ACID 原子性（一个事务中所有操作全部成功，全部失败）一致性（数据库总是从一个一致性的状态转换到另一个一致性的状态）隔离性（一个事务执行过程中不会对另一个事务产生影响）持久性（事务执行完后会写入磁盘，永久保存）
事务隔离级别：Read Uncommitted 读未提交（脏读）Read Committed 读已提交，写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。（不可重复读，事务A和B，A 多次读取同一数据，B 在A多次读取的过程中对数据作了修改并提交，导致A多次读取同一数据时，结果不一致）Repeatable Read 可重复读（innodb默认级别，通过行级锁+MVCC实现。幻读，A在读取范围数据时，B插入了一行，导致A多读了一行，多次读取记录数不同。幻读的定义侧重于多条记录，就是记录条数的变化，而不可重复读侧重于单条记录数据的变化，这样区分原因在于解决幻读需要范围锁，解决不可重复读只需要单条记录加锁。innodb的mvcc处理了只读事务的幻读），对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。Serializable 串行化（对所有读取的行加锁，避免幻读，性能低）。

嵌套事务：mysql没有明确的嵌套事务，START TRANSACTION;SQL1;START TRANSACTION;SQL2;在遇到START TRANSACTION时，前面的事务会被强制commit，可以通过SAVEPOINT和ROLLBACK TO实现类似功能，START TRANSACTION;SQL1;SAVEPOINT P1;SQL2;ROLLBACK TO P1;COMMIT; 这样SQL1会成功，SQL2会失败

死锁：innodb解决方式：检测到死锁的循环依赖后，将有最少行级排它锁的事务回滚，稍后重新执行该事务即可。
自动提交：autocommit，默认，每个sql被当做一个事务执行提交操作。
隐式锁：Innodb采用两阶段锁协议，事务执行时，随时都可能上锁，在commit或rollback后才会释放所有的锁。
显示锁：select ... lock in share mode (读锁)   select ... for update (写锁，处理超售的方法之一)
表级锁：一次性给sql涉及到的所有表加锁，因此不会死锁。
避免死锁：区分度高的列放到组合索引前面、将大事务拆成多个小事务来处理、在并发比较高的系统中，尽量不要显式加锁、减少范围查找、减少连接的表、将复杂SQL分解为多个简单的SQL
间隙锁：innodb在RR隔离级别会加间隙锁（不区分读、写锁），解决幻读问题。不同事务可重复加间隙锁。间隙锁会导致加锁达不到预期的情况。
产生间隙锁的条件：唯一索引N不存；唯一索引范围查询；普通索引加锁。

MVCC Multiversion Concurrency Control 多版本并发控制 在读取不加锁的情况下实现行级锁的效果，实现非阻塞读，只有写写之间相互阻塞。在Read Committed 和 Repeatable Read两个隔离级别下工作。
Innodb中每一行多了几个字段：DB_TRX_ID(当前事务的ID，自动递增) DB_ROLL_PT（指向undo log记录，通过这个指针获得之前版本的数据） DB_RAW_ID（） deleted_flag（事务执行时置位true，commit之后才真正删除）
Read View一致性视图：RC 在事务中每一个select操作前生成 RR 在第一个select操作前生成。InnoDB为每一个事务构造了一个数组m_ids用于保存一致性视图生成瞬间当前所有活跃事务(开始但未提交事务)的ID，只有当前事务修改的未commit版本和所有已提交事务版本允许被访问。
UPDATE操作都是读取当前读(current read)数据进行更新的。

Undo Log: 实现事务的原子性、实现多版本并发控制

Redo Log：innodb特有的。如果每次修改都操作磁盘，IO成本和查找成本都很高。因此采用WAL（Write Ahead Logging）先写日志，再写磁盘。日志文件就叫做redo log（物理日志，固定大小，循环写，记录某个数据页做了什么改动），更新内存，在适当的时候从内存中更新到磁盘。因此具有崩溃恢复（crash-safe）的能力，innodb_flush_log_at_trx_commit 这个参数设置成 1，每次事务持久化。
Bin Log: mysql服务器层，逻辑日志，归档日志，追加写，二进制形式记录，没有 crash-safe 能力。两种模式：statement：记录sql，row：记录修改前和修改后的行内容。sync_binlog 这个参数设置成 1，每次事务的binlog都持久化 。主从复制、数据恢复（需要配合数据库定期备份）。
取ID=2的行->数据页在内存中（不在就从磁盘中读取）->内存中更新数据->写入redo-log prepare（redolog buffer）->写入bin log->更新redo log commit状态（日志写入磁盘），MySQL 使用两阶段（2PC）提交主要解决 binlog 和 redo log 的数据一致性的问题。

更新sql与查询sql不同，它会影响redo log（重做日志）和 binlog（归档日志）。

InnoDB 是另一个公司以插件形式引入 MySQL 的。

性能优化：表结构优化、索引优化、查询优化、应用层优化（实现方式、redis缓存、mongdb分担存储）

服务器性能剖析
用explain分析sql:
type，type主要取值及其表示sql的好坏程度（由好到差排序）：system(const的特例，表中只有一行记录)>const(唯一索引或者主键索引中使用等值查询)>eq_ref(唯一索引或者主键索引)>ref(非唯一索引或者主键索引精确匹配)>range(使用索引来检索给定范围)>index(遍历索引树，内存)>ALL(遍历表，磁盘)。保证range，最好到ref。
key，实际被使用的索引列。
rows, 扫描的行数
Extra，使用优先级 空>Using index>Using Where>Using filesort（九死一生）>Using temporary（十死无生）。

范式：定义表和字段的一些规范。项目中通常混用范式和反范式
选择优化的数据类型（尽量小、尽量简单、需要索引的列避免NULL，改为NOT NULL），DECIMAL支持精确计算，把数据按照最小关系表的形式进行存储
汇总表、缓存表、slot计数器表

索引 索引是在存储引擎层实现而不是mysql服务器层。
索引实现方式：
B-Tree索引（层级更少，所有数据保存在叶子节点，顺序存储，有序链表，天然支持排序和范围查找，索引列的顺序非常重要：最左法则）innodb使用b+树。
哈希索引：只有精确匹配索引所有列的查询才有效，innodb有一个自适应哈希索引的功能，当某些索引使用非常频繁，会基于B-tree索引之上再创建一个哈希索引。
全文索引：针对单词，不能匹配单词中的字母。mysql5.7后支持innodb的中文全文索引，只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引，fulltext key  使用 match 和 against（IN BOOLEAN MODE） 关键字，将ft_min_word_len 改为1，like + %在文本比较少时是合适的
索引创建类型：INDEX、UNIQUE INDEX、FULLTEXT INDEX、INDEX(email(6))、PRIMARY KEY
索引三大优点：
1 大大减少服务器查询时扫描的数据量
2 避免排序和临时表
3 将随机I/O变为顺序I/O
三星索引：索引包含需要查找的全部记录、索引中的数据顺序和查找的排序顺序一致、索引的列包含查询的全部列
聚簇索引（innodb）：索引和数据放在一起，主键索引的叶子节点存的是整行数据，主键->唯一非空列->隐式定义主键。一个表只能有一个聚簇索引。
二级索引：叶子节点内容是主键的值。非主键索引也被称为二级索引（secondary index）。
二次索引：索引和数据分开。
最左前缀，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。
前缀索引：创建前缀索引节省空间，但是会增加查询的扫描行数（回表精确查询），并且加了之后不能使用覆盖索引。key (name(6))   distinct/all 接近 distinct left(email,7)/all 对应：将整个字符串作为索引结构。如果前缀相近，可以使用倒序存储reverse(field_name)、增加hash字段
多列索引、单列索引，(a,b)这个联合索引，单独查询a可以利用，b不行。
选择合适的索引列顺序，上小下大的树形结构是最合理的。
覆盖索引：一个索引包含所有需要查询的字段的值，只需要扫描索引而无需回表。mysql只能使用b-tree索引做覆盖索引。explain:Extra:Using index
延迟关联：将连表查询改为子查询，充分使用索引
索引排序：索引列顺序和order by的顺序完全一致，连表时order by 第一张表时才生效 explain: type:Using index
重复索引：同一列多次定义相同索引类型的索引，应当避免。
冗余索引：多列索引的情况，(a,b) (a) (a,id)，就属于冗余索引了，(b,a)不算。
独立的列：索引列不能是表达式的一部分、也不能是函数的参数。
避免多个范围查询，将范围查询改成精确查询，优化排序。

表数据量大、查询语句复杂、查询语句频繁、慢查询，就要加上索引了。

join原理：MySQL内部采用了一种叫做 nested loop join（嵌套循环连接）的算法。通过驱动表的结果集作为循环基础数据，然后将该结果集的数据一条的作为过滤条件到下一个表中查询数据，然后合并结果集。如果还有第三个参与 Join，如此往复。
join优化：小表作为驱动表，给被驱动表的关联字段加上索引，order by一个表的字段。

自增主键可能是不连续的：SQL错误时、回滚时。

Change Buffer：提高了写的性能。对非唯一的普通索引的新增或更新操作，如果索引B+树的需要新增或更新的数据页不在内存中，则直接更新change buffer，等到后面需要使用这个数据页（真正读到内存中来）的时候，再根据change buffer在内存中做merge合并操作。用于业务场景中的写远大于读时。
mysql有时会选择错误的索引，这时需要更改索引、查询语句、force index(index_name)，引导mysql做出正确选择。

select * from table_name use index(index_name) ... 显示选择索引

查询开销指标：响应时间、扫描的行数、返回的行数。
优化where条件、排序优化、一个复杂的查询还是多个简单的查询（将关联放到应用程序中）、切分查询（分页，每次处理一小部分）、分解关联查询（join改成多条查询）、子查询与join切换
count(列不包含null)，count(*)mysql做了特殊优化，性能最好。
distinct 与 group by 切换
offset limit优化：select * from table_name offset 1000 limit 10 改成 select id from table_name offset 1000 limit 10 和 select * from table_name where id in()
union all 

InnoDB Myisam比较
事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
外键：InnoDB 支持外键。
备份：InnoDB 支持在线热备份。
崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

常用 MySQL 函数：数学函数、时间函数、字符串函数、聚合函数
分表数量级：MySQL 单表容量在500万左右，性能处于最佳状态

主从策略：
单主多从，MySQL Cluster，进行全同步复制时，会等待所有 Slave 节点的 Binlog 都完成写入后，Master 节点的事务才进行提交。
双主单写，一个Master提供线上服务，另一个Master作为备胎。也叫做主备模式

分库和分表是两码事，可能光分库不分表，也可能光分表不分库。
分库：将一个库的数据拆分到多个库，访问时就访问一个库。
分表：把一个表的数据放到多个表中，查询时，就查一个表。单表到几百万时性能就会相对差点，就该分表。
内存读取：
MySQL 在执行读操作时，会先从数据库的缓冲区中读取，如果不存在与缓冲区中就会尝试从内存中加载页面，如果前面的两个步骤都失败了，最后就只能执行随机 IO 从磁盘中获取对应的数据页。
磁盘顺序读取：性能甚至高于内存读取。
索引的目标是减少磁盘随机读写的次数。

二分查找法，又叫折半查找法，基于有序列表。
二叉查找树：左节点<中间节点<右节点。
平衡二叉树（AVL树）：1 是一棵二叉树，2 左右子树的高度差最大值为1。查询快，维护复杂。
B+树：是一种平衡查找树，高度一般为2~4层，所有叶子节点位于同一层。增删改查时间复杂度为O(log n)。

MySQL中有两个kill命令：
kill query thread_id;
kill connection thread_id;


