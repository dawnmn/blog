消息队列中间件的应用场景：异步处理、削峰填谷、应用解耦。
RabbitMQ用erlang开发，erlang是一门函数式面向高并发的编程语言。
**AMQP**（高级消息队列协议）是一个网络协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。
publisher->publish->exchange->router->queue->consumes->consumer

**发布者**（publisher）消息属性 消息确认（确认回执）当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。
队列、交换机和绑定统称为AMQP实体
交换机可以有两个状态：持久（durable）、暂存（transient）。持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会。队列也有持久（durable）、暂存（transient）。
消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。
消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ会重新发送消息。
**交换机**


默认交换机（default exchange）实际上是直连型交换机，每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。
直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。
扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。排行榜更新等全局事件、分发系统广播、群聊分发消息

主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。分发/订阅模式。发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由.分隔开的词语列表。
\* (星号) 用来表示一个单词.
\# (井号) 用来表示任意数量（零个或多个）单词。
头交换机（headers exchange）使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。可以视为直连交换机的另一种表现形式。x-match：any/all

**队列**（queue）存储着即将被应用消费掉的消息。队列在声明（declare）后才能被使用。声明一个队列是幂等的。
持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。
**绑定**（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。

**消费者** push/pull
消息确认：自动确认模式（消息代理（broker）将消息发送给应用后立即删除）/显式确认模式（消费者应用来选择什么时候发送确认回执）
如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。
默认轮询的方式将消息发送给消费者。

如果没有绑定队列到交换器，消息将会丢失。但这个没有所谓，如果没有消费者监听，那么消息就会被忽略。



RabbitMQ实现RPC：客户端将请求数据（json格式）发布到队列A，并且监听队列B。服务器监听队列A，接受请求数据并处理后，返回数据发布到队列B。客户端处理队列B数据。由于一个客户端可以对应多个服务器，需要correlation_id参数确认连接是否对应。
**TTL**


目前有两种方法可以设置消息的 TTL 。第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间，消息过期后会被立刻删除。第二种方法是对消息本身进行单独设置，每条消息的 TTL 可以不同，在消费时判断是否过期（惰性删除）。如果两种方法一起使用，则消息的 TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置 TTL 值时，就会变成"死信" (Dead Message)

**死信**（Dead Letter）是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：
1 消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue属性被设置为false。
2 消息在队列的存活时间超过设置的TTL时间。
3 消息队列的消息数量已经超过最大队列长度。
那么该消息将成为死信。
死信消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。
并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机。

配置死信队列：
1 配置业务队列，绑定到业务交换机上。
2 为业务队列配置死信交换机和路由key。
3 为死信交换机配置死信队列。

**消息持久化**：需要将交换器（创建时配置durable）、队列（创建时配置durable）、消息（投递消息时配置投递模式DeliveryMode为2）都设置持久化，每条消息都持久化会影响性能。
持久化的消息在到达队列时就被写入到磁盘，非持久化的消息一般只保存在内存中 ，在内存吃紧的时候会被换入到磁盘中。
**发布确认**：生产者将信道设置成 confirm 确认模式，所有在该信道上面发布的消息都会被指派 个唯一的 ID（从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ 会发送一个确认 (Basic.Ack) 给生产者(包含消息的唯一 ID)。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号。客户端应采用异步确认提高性能。
**消费确认**：Ack肯定确认。Reject一次只能拒绝一条消息。Nack则可以一次性拒绝多个消息，这是RabbitMQ对AMQP规范的一个扩展。

**Qos**：控制消费者缓存消息的数目，避免消息在消费者端堆积，只用在消息推送模式（Consume）。

连接：AMQP连接通常是长连接。
**连接与通道**：AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。一个特定通道上的通讯与其他通道上的通讯是完全隔离的。建立连接需要7个tcp包（3次握手，4次挥手），成本是很高的。不要反复创建和删除连接和通道，一个线程应当复用同一个连接下的通道，不同的线程不能共享通道，多个线程可以共用同一个连接。应当控制连接数目，消费者和生产者使用不同的连接。对于go语言，应对普通业务，创建一个连接、2个通道即可。

**延迟队列**插件：rabbitmq_delayed_message_exchange，消息数控制在100万以下，可以按时间段将消息缓存到mysql，定时轮询最近的消息到延迟队列。消息先存储在Mnesia数据库，基于erlang定时器，到期后投递到队列。

**集群**cluster 有两种模式，普通模式和镜像模式。
普通模式所有节点中的元数据是一致的，队列里面的数据只会存在创建它的节点上，其他节点除了存储元数据，还存储了指向 Queue 的主节点(owner node)的指针。
当客户端读写不属于该节点的数据时，会在节点之间传递数据。
缺点：单点故障、单点瓶颈。
镜像模式会在节点中同步队列的数据，最终的队列数据会存在于每个节点中。分为all（所有节点镜像）、exactly（指定镜像节点数目）、nodes（指定哪些节点镜像）三种模式。
缺点：性能不好，集群内部的同步通讯会占用大量的网络带宽。


