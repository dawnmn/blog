**指数**
![](../images/指数.png)
**对数**
在计算机科学中，除非特别声明，所有的对数都是以2为底的。
对数公式证明思路：将对数转化成指数，再证明指数相等。
![](../images/对数-1.png)
![](../images/对数-2.png)
**级数**
![](../images/级数-1.png)
![](../images/级数-所有自然数的和.png)
**取模**
mod运算，即求余运算，得到的是一个数除以另一个数的余数。
![](../images/模运算-1.png)
**递归**
基本法则：
1. 基准情形。必须总要有某些基准的情形，它们不用递归就能求解。
2. 要有进展。递归调用必须总能够朝着一个基准情形进展。
3. 设计法则。假设所有的递归调用都能运行。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

递归转循环的思路：找到基准情形、进展、计算的代码，在循环中复刻。
**时间复杂度**
平均时间复杂度、最坏时间复杂度
![](../images/时间复杂度O.png)

求一串数字的连续最大和：
```
func alg(a []int) int {
	var max int
	var tmp int
	for i := 0; i < len(a); i++ {
		tmp += a[i]
		if max < tmp {
			max = tmp
		} else if tmp < 0 {
			tmp = 0
		}
	}
	return max
}
```
**栈**
列表数据结构：
`[]any`
链表数据结构：
```
type Node struct {
	Val  any
	Next *Node
}
type Stack struct {
	top    *Node
	length int
}
```
**队列**
列表数据结构：
`[]any`
链表数据结构：
```
type Node struct {
	Data any
	Next *Node
}
type Queue struct {
	head   *Node
	tail   *Node
	length int
}
```
**集合**
数据结构：`map[any]bool`
**树**
树的深度：根节点到当前节点的路径长度。
树的高度：当前节点到叶子节点的最大路径长度。
**二叉树**
数据结构：
```
type BNode struct {
	Value int
	Left  *BNode
	Right *BNode
}
```
先序遍历、中序遍历、后序遍历、层次遍历。先序、中序、后序其实指的是父节点被访问的次序。若在遍历过程中，父节点先于它的子节点被访问，就是先序遍历；父节点被访问的次序位于左右子节点之间，就是中序遍历；访问完左右子节点之后再访问父节点，就是后序遍历。不论是先序遍历、中序遍历还是后序遍历，总是先访问左子节点，再访问右子节点。而层次遍历，就是按照从上到下、从左向右的顺序访问二叉树的每个节点，存储结构为数组时使用。
**二叉查找树**
bst，对于树中每个节点X，它的左子树中所有项的值均小于X中的项，而它的右子树中所有项的值均大于X中的项。
![](../images/二叉查找树.png)
数据结构：
```
type BSNode struct {
	key    any
	parent *BSNode
	left   *BSNode
	right  *BSNode
}
type BinarySearch struct {
	Root *BSNode
}
```
最小值为最左叶子，最大值为最右叶子。
查询和插入操作相似：自顶向下比较。
删除：删除的节点下有两个子树，用右子树中的最小元素来替换删除的节点；删除的节点只有一个子树，那么该子树直接替换被删除的节点；其它情况，直接删除节点。
中序遍历可以实现排序，时间复杂度O(N)。
平均时间复杂度O(logN)，最大时间复杂度O(N)（比如插入有序数据时，二叉树退化为链表）。
**AVL树**
平衡二叉查找树，每个节点的左子树和右子树高度最多差1。
![](../images/AVL树.png)

高度 H<=1.44log(N+2)-1.328，因此查找的最坏时间复杂度为O(logN)

AVL树的查询与二叉查找树相同，插入和删除多了再平衡树的步骤。时间复杂度O(logN)。
平衡因子 ：节点的左子树高度-节点的右子树高度
右旋
情况：当前结点的平衡因子>1 && 当前结点的左子树的平衡因子>=0。
方式：左子结点变为当前结点的父结点，左子结点的右子结点变为当前结点的左子结点，右子结点保持不变。
![](../images/avl树-右旋.jpg)

左旋
情况：当前结点的平衡因子<-1 && 当前结点的右子树的平衡因子<=0。
方式：右子结点变为当前结点的父结点，右子结点的左子结点变为当前结点的右子结点，左子结点保持不变。
![](../images/avl树-左右旋.jpg)

左右旋
情况：当前结点的平衡因子>1 && 当前结点的左子树的平衡因子<0。
![](../images/avl树-左右旋.jpg)

右左旋
情况：当前结点的平衡因子<-1 && 当前结点的右子树的平衡因子>0。
![](../images/avl树-右左旋.jpg)
**满二叉树**
一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
满二叉树 != 完全二叉树
**完全二叉树**
若设二叉树的深度为h，除第h层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边。时间复杂度为O(logN)，使用数组实现而不需要链表。
**最小堆**
又叫二叉堆，是一种完全二叉树，比二叉查找树简单，用于优先级队列。
任一节点均小于等于它的左右子节点，位于堆顶节点的值最小。
![](../images/二叉堆示例.png)

结构性质：对于数组中任一位置i（i从1开始）上的节点，其左子节点在位置2i上，右子节点在2i+1上，父节点在i/2位置上。
堆序性质：对于任一节点i，i的父节点关键字小于等于i的关键字，根节点除外（没有父节点）。
插入：上滤，将新节点放入尾部，与父节点比较并交换位置，直到根节点。
![](../images/堆-上滤-1.png)
![](../images/堆-上滤-2.png)

删除最小节点：下滤，将尾节点放入根节点，与子节点比较并交换位置，直到没有子节点。
![](../images/堆-下滤-1.png)

```
func (h *Heap[T]) down(parent int) {
	lessIdx := parent
	lChild, rChild := (parent<<1)+1, (parent<<1)+2
	if lChild < len(h.heaps) && h.lessFunc(h.heaps[lChild], h.heaps[lessIdx]) {
		lessIdx = lChild
	}
	if rChild < len(h.heaps) && h.lessFunc(h.heaps[rChild], h.heaps[lessIdx]) {
		lessIdx = rChild
	}
	if lessIdx == parent {
		return
	}
	h.swap(lessIdx, parent)
	h.down(lessIdx)
}
```
构建堆：从下往上、从右到左，将每个非叶子节点当作根结点，将其和其子树调整成堆。时间复杂度O(N)
![](../images/构建堆示例.png)
**红黑树**
是二叉查找树，是特化的AVL树（黑色完美平衡）。红色、黑色为节点作色，是节点的一个属性。具有如下特性：
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个红色结点的两个子结点一定都是黑色。
5. 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。



红黑树的查询与二叉查找树相同，插入和删除多了修复红黑树的步骤。时间复杂度O(logN)。

插入时，新的节点为红色。
情形1:新节点N位于树的根上，没有父节点。新节点置为黑色。
```
void insert_case1(node *n){
	 if(n->parent == NULL)
			 n->color = BLACK;
	 else
			 insert_case2 (n);
}
```
情形2:新节点的父节点P是黑色。不用修改。
```
void insert_case2(node *n){
	 if(n->parent->color == BLACK)
			 return; /* 树仍旧有效*/
	 else
			 insert_case3 (n);
}
```
情形3:父节点P和叔父节点U都是红色（此时新插入节点N做为P的左子节点或右子节点都属于情形3）。将它们两个重绘为黑色并重绘祖父节点G为红色，处理祖父节点。
```
void insert_case3(node *n){
	 if(uncle(n) != NULL && uncle (n)->color == RED) {
			 n->parent->color = BLACK;
			 uncle (n)->color = BLACK;
			 grandparent (n)->color = RED;
			 insert_case1(grandparent(n));
	 }
	 else
			 insert_case4 (n);
}
```
![](../images/红黑树-右旋.png)
![](../images/红黑树-左旋.png)
在余下的情形下，我们假定父节点P是其祖父G的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。
情形4:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。对父节点P左旋，处理父节点。
```
void insert_case4(node *n){
	 if(n == n->parent->right && n->parent == grandparent(n)->left) {
			 rotate_left(n);
			 n = n->left;
	 } else if(n == n->parent->left && n->parent == grandparent(n)->right) {
			 rotate_right(n);
			 n = n->right;
	 }
	 insert_case5 (n);
}
```
情形5:父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。对祖父节点G右旋，处理父节点。
```
void insert_case5(node *n){
	 n->parent->color = BLACK;
	 grandparent (n)->color = RED;
	 if(n == n->parent->left && n->parent == grandparent(n)->left) {
			 rotate_right(n->parent);
	 } else {
			 /* Here, n == n->parent->right && n->parent == grandparent (n)->right */
			 rotate_left(n->parent);
	 }
}
```

删除：
如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。
删除一个红色节点，不用修复。
被删除节点是黑色而它的儿子是红色，将儿子变为黑色。
要删除的节点和它的儿子二者都是黑色：共有6种情形。
**B树**
为什么使用：
数据在磁盘中，因为CPU指令执行速度远高于磁盘访问，因此用复杂的指令去减少磁盘的访问次数。这与通常的数据在内存中的情况不同。M叉树的高度大约为LogmN，使用M叉树替代二叉树，以降低树的高度（查询时间复杂度）。
B树的阶：子节点最大值M。
阶为M的B树是具有如下特性的M叉平衡查找树：
非叶节点可以存储M-1个关键字。
树的根要么是树叶，要么根的子节点数目在2和M之间。
除根外，所有非叶节点的子节点数在M/2和M之间。
所有叶节点在同一层，每个叶节点的数据项个数在L/2和L之间。

插入：子节点满员会进行分裂，如果父节点也满员，会一直向上分裂。直到根节点，这时创建新的根，将分裂的两个根作为新的根节点的子节点。
删除：被删除数据所在的叶节点数据项个数小于L/2时，如果相邻节点不丰满，则相邻节点领养，如果丰满，则向父节点借一个元素。

**B+树**
B树的变种，数据只存储在叶子节点，叶子节点构成一个有序链表，能更好支持范围查找。

