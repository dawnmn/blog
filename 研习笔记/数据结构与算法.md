**指数**
![](../images/指数.png)
**对数**
在计算机科学中，除非特别声明，所有的对数都是以2为底的。
对数公式证明思路：将对数转化成指数，再证明指数相等。
![](../images/对数-1.png)
![](../images/对数-2.png)
**级数**
![](../images/级数-1.png)
![](../images/级数-所有自然数的和.png)
**取模**
mod运算，即求余运算，得到的是一个数除以另一个数的余数。
![](../images/模运算-1.png)
**递归**
基本法则：
1. 基准情形。必须总要有某些基准的情形，它们不用递归就能求解。
2. 要有进展。递归调用必须总能够朝着一个基准情形进展。
3. 设计法则。假设所有的递归调用都能运行。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

递归转循环的思路：找到基准情形、进展、计算的代码，在循环中复刻。
**时间复杂度**
平均时间复杂度、最坏时间复杂度
![](../images/时间复杂度O.png)

求一串数字的连续最大和：
```
func alg(a []int) int {
	var max int
	var tmp int
	for i := 0; i < len(a); i++ {
		tmp += a[i]
		if max < tmp {
			max = tmp
		} else if tmp < 0 {
			tmp = 0
		}
	}
	return max
}
```
**栈**
列表数据结构：
`[]any`
链表数据结构：
```
type Node struct {
	Val  any
	Next *Node
}
type Stack struct {
	top    *Node
	length int
}
```
**队列**
列表数据结构：
`[]any`
链表数据结构：
```
type Node struct {
	Data any
	Next *Node
}
type Queue struct {
	head   *Node
	tail   *Node
	length int
}
```
**集合**
数据结构：`map[any]bool`
**树**
树的深度：根节点到当前节点的路径长度。
树的高度：当前节点到叶子节点的最大路径长度。
**二叉树**
数据结构：
```
type BNode struct {
	Value int
	Left  *BNode
	Right *BNode
}
```
先序遍历、中序遍历、后序遍历、层次遍历。先序、中序、后序其实指的是父节点被访问的次序。若在遍历过程中，父节点先于它的子节点被访问，就是先序遍历；父节点被访问的次序位于左右子节点之间，就是中序遍历；访问完左右子节点之后再访问父节点，就是后序遍历。不论是先序遍历、中序遍历还是后序遍历，总是先访问左子节点，再访问右子节点。而层次遍历，就是按照从上到下、从左向右的顺序访问二叉树的每个节点，存储结构为数组时使用。
