**指数**
![](../images/指数.png)
**对数**
在计算机科学中，除非特别声明，所有的对数都是以2为底的。
对数公式证明思路：将对数转化成指数，再证明指数相等。
![](../images/对数-1.png)
![](../images/对数-2.png)
**级数**
![](../images/级数-1.png)
![](../images/级数-所有自然数的和.png)
**取模**
mod运算，即求余运算，得到的是一个数除以另一个数的余数。
![](../images/模运算-1.png)
**递归**
基本法则：
1. 基准情形。必须总要有某些基准的情形，它们不用递归就能求解。
2. 要有进展。递归调用必须总能够朝着一个基准情形进展。
3. 设计法则。假设所有的递归调用都能运行。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

递归转循环的思路：找到基准情形、进展、计算的代码，在循环中复刻。
**时间复杂度**
平均时间复杂度、最坏时间复杂度
![](../images/时间复杂度O.png)

求一串数字的连续最大和：
```
func alg(a []int) int {
	var max int
	var tmp int
	for i := 0; i < len(a); i++ {
		tmp += a[i]
		if max < tmp {
			max = tmp
		} else if tmp < 0 {
			tmp = 0
		}
	}
	return max
}
```
**栈**
列表数据结构：
`[]any`
链表数据结构：
```
type Node struct {
	Val  any
	Next *Node
}
type Stack struct {
	top    *Node
	length int
}
```
**队列**
列表数据结构：
`[]any`
链表数据结构：
```
type Node struct {
	Data any
	Next *Node
}
type Queue struct {
	head   *Node
	tail   *Node
	length int
}
```