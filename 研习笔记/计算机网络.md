>应用层 http https smpt ftp ssh telnet | ntp(网络时间同步) dhcp(动态配置IP地址) | dns
>传输层 tcp udp
>网络层 ip数据报
>链路层 传输ip数据报组装成的帧，在两个相邻节点的链路上传输帧，mac地址
>物理层 传输bit字节

**HTTP**
MIME类型：http所传输的资源的类型。
示例：
* text/html HTML格式的文本文档
* text/plain 普通的 ASCII 文本文档
* image/jpeg 图片
* application/json json格式的数据

URL 
`<scheme>://<user>:<password>@<host>:<port>/<path>`
URL 最重要的 3 个部分是方案（scheme）、主机（host）和路径（path）。
scheme方案：访问资源所使用的协议类型。
服务器地址
资源路径
URL不是HTTP协议所独有的。
URL使用ascii编码，对于其它字符编码和特殊字符会转义。

HTTP 报文包括3个部分：
起始行
首部字段（header）
主体（body）

基本的HTTP连接处理：
(a) 浏览器从 URL 中解析出服务器的主机名；
(b) 浏览器将服务器的主机名转换成服务器的 IP 地址；
(c) 浏览器将端口号（如果有的话）从 URL 中解析出来；
(d) 浏览器建立一条与 Web 服务器的 TCP 连接；
(e) 浏览器向服务器发送一条 HTTP 请求报文；
(f) 服务器向浏览器回送一条 HTTP 响应报文；
(g) 关闭连接，浏览器显示文档。

HTTP 报文包括3个部分：
起始行
首部字段（header）
主体（body）
请求报文的格式：
```
<method> <request-URL> <version>
<headers>
<entity-body>
```
响应报文的格式：
```
<version> <status> <reason-phrase>
<headers>
<entity-body>
```

HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。
OPTIONS 方法请求 Web 服务器告知其支持的各种功能。不会访问服务器实际资源。

跨源资源共享（CORS）是一种基于HTTP头的机制，允许服务器标示其它源（域、协议和端口），解决XMLHttpRequest和Fetch API遵循同源策略的问题。
首次交互是预检请求/响应：
```
OPTIONS /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type

HTTP/1.1 204 No Content
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
```

Origin 表示需要跨域的源，Access-Control-Max-Age表示预检请求有效期。

预检请求完成之后，发送实际请求：
```
GET /resources/credentialed-content/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Referer: https://foo.example/examples/credential.html
Origin: https://foo.example
Cookie: pageAccess=2

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

Access-Control-Allow-Credentials true 表示支持cookie等身份凭证信息。

重定向的关键：302 Location
![](../images/重定向.png)


CGI（Common Gateway Interface）通用网关接口

cookie通常由服务器创建。
![](../images/密码.png)


**对称加密**：加密和解密都是使用同一个密钥，常见的对称加密算法有DES、3DES和AES。
优点：计算量小、加密效率高，适合加密比较大的数据。
缺点：密钥在传输过程中无法保证不被截获。

**非对称加密**，加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。常用的非对称加密算法是 RSA 算法。
优点：加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。
缺点：计算量比较大，加密和解密速度相比对称加密慢很多。

![](../images/959982414-5e11d6393cab7_fix732.png)
![](../images/2641864607-5e11d65c74244_fix732.png)
OpenSSL 是 SSL 和 TLS 最常见的开源实现。

**HTTPS SSL 隧道协议**，该协议解决代理不能读取HTTPS的 HTTP 首部，就无法知道应该将请求转向何处的问题。HTTP 通过 CONNECT 方法来发送明文形式的端点信息。CONNECT 方法会告诉代理，打开一条到所期望主机和端口号的连接隧道，并进行数据传输。
```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/1.1N
<raw SSL-encrypted data would follow here...>
```

**NAT**（Network Address Translation）网络地址转换
当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。
SNAT（Source NAT，SNAT）：修改数据包的源地址。
DNAT（Destination NAT，DNAT）：修改数据包的目的地址。
![](../images/hzkla28zra.png)
**DNS**：客户端先检查本地的 DNS 缓存，DNS 是以存活时间（Time to Live，TTL）来衡量缓存的有效情况的，本地 DNS 收到查询请求后，会按照“是否有www.icyfenix.com.cn的权威服务器”→“是否有icyfenix.com.cn的权威服务器”→“是否有com.cn的权威服务器”→“是否有cn的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。它将会得到“cn的权威服务器”的地址记录，然后通过“cn的权威服务器”，得到“com.cn的权威服务器”的地址记录，以此类推，最后找到能够解释www.icyfenix.com.cn的权威服务器地址。通过“www.icyfenix.com.cn的权威服务器”，查询www.icyfenix.com.cn的地址记录。
`<link rel="dns-prefetch" href="//domain.not-icyfenx.cn">`前端对域名预加载。
![](../images/DNS重定向.png)


**CDN** 路由解析：
1 架设好“icyfenix.cn”的服务器后，将服务器的 IP 地址在你的 CDN 服务商上注册为“源站”，注册后你会得到一个 CNAME，即本例中的“icyfenix.cn.cdn.dnsv1.com.”。
2 将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。
3 当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。
4 本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS，这个 DNS 服务将根据一定的均衡策略和参数，如拓扑结构、容量、时延等，在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的，将它的 IP 代替源站的 IP 地址，返回给本地 DNS。
5 浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问。

CDN 获取源站资源的过程被称为“内容分发”：
主动分发（Push）：分发由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。
被动回源（Pull）：当某个资源首次被用户请求的时候，CDN 缓存节点发现自己没有该资源，就会实时从源站中获取，这时资源的响应时间可粗略认为是资源从源站到 CDN 缓存节点的时间，再加上资源从 CDN 发送到用户的时间之和。


**XSS**（cross site script） 在网站上注入恶意客户端代码（js脚本、链接、html实体），过滤输入请求，strip_tags、htmlspecialchars、htmlentities 
**CSRF** （cross site request forgery）攻击者诱导用户进入第三方网站，在第三方网站中向被攻击网站发送跨站请求，1 同源检测 2 token 将CSRF Token输出到页面中，请求时携带Token，服务器端验证token。

HTTP报文是纯文本字符串。
|  编码   |  文本   | 说明   |
| --- | --- | --- |
|301|Moved Permanently|在请求的链接被移除时使用|
|302|Found|在请求临时的链接使用
|400|Bad Request|客户端请求错误
|403|Forbidden|请求被服务器拒绝
|404|Not Found|无法找到所请求的 URL
|500|Internal Server Error|服务器错误
|502|Bad Gateway|代理或网关错误(无法连接到其父网关) php-fpm 没有可用的worker进程（worker进程不够用了）
|504|Gateway Timeout|代理或网关超时(等待另一服务器响应超时) worker进程响应超时（php代码执行超时）

**Websocket**:Websocket与HTTP(80)和HTTPS(443)使用相同的TCP端口。服务器可以随时主动给客户端下发数据。WebSocket 是独立的、建立在TCP上的协议。Websocket 通过 HTTP/1.1 协议的101状态码进行握手。

**HTTP2**
HTTP1.x和HTTP2的区别：
新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能，服务器可以对一个客户端请求发送多个响应。
HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？

HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
*****


**UDP**
无连接的，发送数据之前不需要建立连接，减少开销和发送数据之前的延时，支持一对一、一对多、多对一和多对多的交互通信，使用最大努力交付，不保证可靠交互，没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低，首部开销小，只有8个字节，比 TCP 的20个字节的首部要短。
**TCP**
有连接的，发送数据之前需要建立连接，数据发送完后需要释放连接，只支持一对一的通信，提供可靠交互（无差错、不丢失、不重复，并且按序到达），全双工通信，允许通信双方的应用进程在任何时候都能发送数据。

tcp三次握手：服务器listen状态->客户端发送syn报文，syn_send状态->服务器接收报文，发送syn+ack报文，syn_recv状态->客户端接收报文，发送ack报文，established状态->服务器接收报文，established状态。
为什么三次握手：双方确认自己与对方的发送与接收是正常的。

tcp四次挥手：客户端established，服务器端established->客户端发送fin报文，并停止发送数据，fin_wait1状态->服务器接收报文，发送ack报文，close_wait状态->客户端接收报文，fin_wait2状态->服务器也没有数据需要发送后，发送fin+ack报文，lask_ack状态->客户端接收报文，发送ack报文，time_wait状态,超时后进入closed状态->服务器接受报文，closed状态
为什么四次挥手：tcp的半关闭特性决定的，即连接的一端发送完数据之后，还能接受另一端的数据的能力。
TIME-WAIT是什么，为什么必须等待 2MLS(最大数据段生命周期，默认2分钟):
* 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到。
* 保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到`FIN`对应的`ACK`消息。
TIME-WAIT可能导致端口耗尽。

心跳机制：定时发送一个自定义的数据包，以确认双发是否保持连接。

建立套接字的步骤：创建socket，绑定socket到指定ip和端口，开始监听连接，接受客户端数据，关闭socket。

系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。
client最大tcp连接数：tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535。
server最大tcp连接数：理论上是客户端ip数×客户端port数，在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数。
服务器端最多可以拥有65535个Bind的Socket，最多可以开65535个服务器进程，但是你要知道这个能够连接客户端的数量没有任何关系。

同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。
阻塞：程序会一直等待。非阻塞：程序轮询等待。
现代操作系统都是采用虚拟存储器，对32位操作系统而言，它的寻址空间为4G。为了保证用户进程不能直接操作内核，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节，供内核使用，称为内核空间，而将较低的3G字节，供各个进程使用，称为用户空间。
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。当进程进入阻塞状态，是不占用CPU资源的。
网络IO的本质是socket的读取，IO的数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
1 等待网络数据到达网卡并读取到内核缓冲区，数据准备好。
2 从内核缓冲区复制数据到进程空间。
文件描述符（File descriptor），FD，是一个指向文件的引用，是一个索引值。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
fd=io=连接

链表、数组区别：数组查询快，插入删除慢很多，长度固定，顺序存储，链表插入删除快，查询线性时间慢，长度动态灵活，随机存储。相同数量的元素，链表更耗内存（存储了前后指针）

在一个线程中，同步阻塞只能等待一个连接，I/O 复用可以等待多个连接（kernel监控），但一次只能处理一个连接，用于海量并发连接且大量连接idle的场景。
![](../images/1204119-20210208204544304-720218418.png)
I/O Multiplexing首先向kernel发起system call，传入file descriptor和感兴趣的事件(readable、writable等)让kernel监测，当其中一个或多个fd数据就绪，就会返回结果。程序再发起真正的I/O操作recvfrom读取数据，或者write()。
在一个线程中对N个套接字进行事件捕获，当读写事件产生后再真正read()或者write()

select缺点：性能开销大，文件描述符数量少。
epoll是一种I/O事件通知机制，内部存储：
监听列表：所有要监听的文件描述符，使用红黑树；
就绪列表：所有就绪的文件描述符，使用链表；
select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是在epoll上注册fd要监听的事件类型；epoll_wait则是等待事件的产生。

epoll的连接上限是最大可以打开文件的数目。

**IPV4**
经典模式：
A类:1.0.0.0~126.255.255.255,默认子网掩码/8,即255.0.0.0，一个子网最多容纳1677万多个ip
(其中127.0.0.0~127.255.255.255为环回地址,用于本地环回测试等用途)
B类:128.0.0.0~191.255.255.255,默认子网掩码/16,即255.255.0.0，一个子网最多容纳65534个ip
C类:192.0.0.0~223.255.255.255,默认子网掩码/24,即255.255.255.0，一个子网最多容纳254个ip
要想在同一网段，必需做到网络标识一样。

CIDR划分法比较灵活，不再区分A~E类，并且随意使用子网掩码，因此，可以把IP段尽量划分的小一些，每个CIDR段分配给一个单位。

IP地址组成为：网络号+子网号+主机号。
网络号是在广域网中的集合标识，子网号是在网络号中的集合标识。实际场景中，单个网络支持的机器数目有限，对于a类和b类网络号会造成ip浪费。因此在网络号之下增加一层子网号。
为了使目的主机所在网路的路由器能够很方便的找到目的子网，引入子网掩码的概念。
子网掩码的高24位为全1，等价于 11111111.11111111.11111111.00000000，即255.255.255.0。

私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义：
A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255
B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255
C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255