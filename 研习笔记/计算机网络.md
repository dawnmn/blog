应用层 http https smpt ftp ssh telnet | ntp(网络时间同步) dhcp(动态配置IP地址) | dns
传输层 tcp udp
网络层 ip数据报
链路层 传输ip数据报组装成的帧，在两个相邻节点的链路上传输帧，mac地址
物理层 传输bit字节

upd的特点：无连接的，发送数据之前不需要建立连接，减少开销和发送数据之前的延时，支持一对一、一对多、多对一和多对多的交互通信，使用最大努力交付，不保证可靠交互，没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低，首部开销小，只有8个字节，比 TCP 的20个字节的首部要短
tcp的特点：有连接的，发送数据之前需要建立连接，数据发送完后需要释放连接，只支持一对一的通信，提供可靠交互（无差错、不丢失、不重复，并且按序到达），全双工通信，允许通信双方的应用进程在任何时候都能发送数据

tcp三次握手：服务器listen状态->客户端发送syn报文，syn_send状态->服务器接收报文，发送syn+ack报文，syn_recv状态->客户端接收报文，发送ack报文，established状态->服务器接收报文，established状态
为什么三次握手：双方确认自己与对方的发送与接收是正常的。

tcp四次挥手：客户端established，服务器端established->客户端发送fin报文，并停止发送数据，fin_wait1状态->服务器接收报文，发送ack报文，close_wait状态->客户端接收报文，fin_wait2状态->服务器也没有数据需要发送后，发送fin+ack报文，lask_ack状态->客户端接收报文，发送ack报文，time_wait状态,超时后进入closed状态->服务器接受报文，closed状态
为什么四次挥手：tcp的半关闭特性决定的，即连接的一端发送完数据之后，还能接受另一端的数据的能力。
TIME-WAIT是什么，为什么必须等待 2MLS:等待 2MLS 可以保证客户端最后一个报文段能够到达服务器。

建立套接字的步骤：创建socket，绑定socket到指定ip和端口，开始监听连接，接受客户端数据，关闭socket。

HTTP报文是纯文本字符串，不是二进制代码
|301|Moved Permanently|在请求的链接被移除时使用
|302|Found|在请求临时的链接使用
|400|Bad Request|告知客户端发送了错误请求
|403|Forbidden|请求被服务器拒绝
|404|Not Found|无法找到所请求的 URL
|413|Request entiry too large|请求实体过大
|500|Internal Server Error|服务器遇到错误
|502|Bad Gateway|代理或网关错误(无法连接到其父网关) php-fpm 没有可用的worker进程（worker进程不够用了）
|503|Service Unavailable|无法为请求提供服务
|504|Gateway Timeout|代理或网关超时(等待另一服务器响应超时) worker进程响应超时（php代码执行超时）

心跳机制：定时发送一个自定义的数据包，以确认双发是否保持连接。

Websocket:Websocket与HTTP(80)和HTTPS(443)使用相同的TCP端口。服务器可以随时主动给客户端下发数据。WebSocket 是独立的、建立在TCP上的协议。Websocket 通过 HTTP/1.1 协议的101状态码进行握手。

HTTP1.x和HTTP2的区别：
新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。
1. HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？

HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；