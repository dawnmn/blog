单体系统的缺陷：缺乏隔离、自治、技术异构能力，没法做到单独停止、更新、升级，需要制定专门的停机更新计划。
SOA，Service-Oriented Architecture，面向服务架构，过时的架构。
微服务架构（Microservices）
微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。
微服务追求的是更加自由的架构风格，摒弃了几乎所有SOA里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”。

云原生：DevOps+持续交付+微服务+容器。
符合原原生架构的落地应用体系是采用k8s+docker进行容器化部署，基于微服务架构开发前后端完全分离的应用，提高灵活性和可维护性，借助敏捷迭代方法支持功能持续迭代完善的对方工具，支持上线发布自动化利用云平台设施实现弹性伸缩，动态调整，最优化资源利用率，这样的架构共建应用简便快捷，部署应用轻松自如，运行应用5G流量分布秒杀传统的为应用架构，吊打以往的IT建设模式，是整个互联网技术发展到今日的集大成体系。

边车代理模式：由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，这个代理除了实现正常的服务间通信外，还接收来自控制器的指令（熔断、认证、度量、监控、负载均衡等）
RESTful 资源表征状态转移，面向资源来抽象问题。降低的服务接口的学习成本，资源天然具有集合与层次结构(GET /users/icyfenix/cart/2),绑定于 HTTP 协议，使用HTTP的方法和状态码。

信息密度：二进制>yaml>json>xml

RPC的三个问题：表示数据、传递数据、表示方法。
REST：面向资源编程，资源表征状态转移。
REST 与 RPC 作为主流的两种远程调用方式，应用场景上是有区别的。REST用在C/S，RPC用在服务间调用。

事务的概念虽然最初起源于数据库系统，但不局限于数据库。
本地事务：单个应用使用单个数据源：ACID，超卖用lock in share mode
全局事务：单个事务使用多个数据源：XA，二阶段提交（2 Phase Commit，2PC，准备阶段，提交阶段，存在单点问题、性能问题、一致性风险）
共享事务：多个不同的服务共用同一个数据源
分布式事务：多个服务同时访问多个数据源，CAP，可靠消息队列，靠着持续重试来保证可靠性

CAP 定理（Consistency、Availability、Partition Tolerance Theorem）
一致性 代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。
可用性 代表系统不间断地提供服务的能力，理解可用性要先理解与其密切相关两个指标：可靠性（Reliability）和可维护性（Serviceability）。
分区容忍性 代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。
理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失P性质。一般来说跨区域的系统，设计师无法舍弃P性质，那么就只能在数据一致性和可用性上做一个艰难选择。

如果放弃分区容忍性（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的。
如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，可以通过 2PC/3PC 等手段同时获得分区容忍性和一致性。银行、证券这些涉及金钱交易的服务，宁可中断也不能出错。
如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择。大多数 NoSQL 库（redis等）和支持分布式的缓存框架。

BASE可靠事件队列：用户账号扣款、商家账号收款、库存商品例子，消息队列服务器将在每次轮询的时候持续地向未响应的服务重复发送消息，所有被消息服务器发送的消息都必须具备幂等性，通常的设计是让消息带上一个唯一的事务 ID，以保证一个事务中的出库、收款动作会且只会被处理一次。最大努力交付，不支持回滚，缺乏隔离性。

TCC事务：Try-Confirm-Cancel
Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），冻结并暂存全部需用到的业务资源（保障隔离性）。
Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理，解冻资源。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。
Cancel：取消执行阶段，解冻 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。
TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面。TCC 事务具有较强的隔离性，避免了“超售”的问题。
局限：业务侵入性很强，如果用户、商家的账号余额由银行管理，也就无法完成冻结款项、解冻、扣减这样的操作。

SAGA事务：大事务拆分若干个原子事务，为每一个子事务设计对应的补偿动作，Ti与 Ci都具备幂等性。Ti与 Ci满足交换律（Commutative），即先执行 Ti还是先执行 Ci，其效果都是一样的。Ci必须能成功提交。如果 T1到 Tn均成功提交，那事务顺利完成，否则采用正向恢复（最大努力交付）或反向恢复（补偿机制）

DNS：客户端先检查本地的 DNS 缓存，DNS 是以存活时间（Time to Live，TTL）来衡量缓存的有效情况的，本地 DNS 收到查询请求后，会按照“是否有www.icyfenix.com.cn的权威服务器”→“是否有icyfenix.com.cn的权威服务器”→“是否有com.cn的权威服务器”→“是否有cn的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。它将会得到“cn的权威服务器”的地址记录，然后通过“cn的权威服务器”，得到“com.cn的权威服务器”的地址记录，以此类推，最后找到能够解释www.icyfenix.com.cn的权威服务器地址。通过“www.icyfenix.com.cn的权威服务器”，查询www.icyfenix.com.cn的地址记录。
<link rel="dns-prefetch" href="//domain.not-icyfenx.cn">前端对域名预加载。

CDN 路由解析：
1 架设好“icyfenix.cn”的服务器后，将服务器的 IP 地址在你的 CDN 服务商上注册为“源站”，注册后你会得到一个 CNAME，即本例中的“icyfenix.cn.cdn.dnsv1.com.”。
2 将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。
3 当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。
4 本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS，这个 DNS 服务将根据一定的均衡策略和参数，如拓扑结构、容量、时延等，在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的，将它的 IP 代替源站的 IP 地址，返回给本地 DNS。
5 浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问。

CDN 获取源站资源的过程被称为“内容分发”：
主动分发（Push）：分发由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。
被动回源（Pull）：当某个资源首次被用户请求的时候，CDN 缓存节点发现自己没有该资源，就会实时从源站中获取，这时资源的响应时间可粗略认为是资源从源站到 CDN 缓存节点的时间，再加上资源从 CDN 发送到用户的时间之和。

四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。

引入缓存的理由：
为缓解 CPU 压力而做缓存：把方法运行结果存储起来、把原本要实时计算的内容提前算好等
缓解 I/O 压力而做缓存：譬如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩部件（如缓存中间件）的访问等。
是典型以空间换时间来提升性能的手段。

OAuth 
授权码模式（Authorization Code）
隐式授权模式（Implicit）
密码模式（Resource Owner Password Credentials）
客户端模式（Client Credentials）
授权码模式开放授权，允许用户向第三方应用提供某一网站的私密数据，而不用将用户的账号密码提供给第三方。以令牌（Token）代替用户密码作为授权的凭证。有了令牌之后，哪怕令牌被泄漏，也不会导致密码的泄漏；令牌上可以设定访问资源的范围以及时效性；每个应用都持有独立的令牌，哪个失效都不会波及其他。
授权码模式：
1 第三方应用先要到授权服务器上进行注册，所谓注册，是指向认证服务器提供一个域名地址，然后从授权服务器中获取 ClientID 和 ClientSecret，
2 第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI
3 如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数
4 第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。
5 授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。
6 资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。
访问令牌的时效性一般设计的比较短，因为很难（需要付出较大代价）有其他方式让它失效。

JWT是一种广泛使用的令牌格式，JSON结构，可用于单客户端对应多服务器的场景。无状态（难以统计实时在线人数）,令牌难以主动失效。

客户端如何加密都不能代替 HTTPS。

摘要也称之为数字摘要（Digital Digest）或数字指纹（Digital Fingerprint）。
加密与摘要的本质区别在于加密是可逆的，逆过程就是解密。
对称加密：加密和解密使用相同的密钥。
非对称加密：从根本上解决了密钥分发的难题，它将密钥分成公钥和私钥。
TLS 1.2：无法窃听（加密传输）、无法篡改（一旦篡改通信算法会立刻发现）、无法冒充（证书验证身份）

分布式共识算法用于实现CAP

状态转移：以同步为代表的数据复制方法
让分布式系统内部暂时容忍存在不同的状态，但最终能够保证大多数节点的状态达成一致，让分布式系统在外部看来始终表现出整体一致的结果。

Quorum 机制，少数节点服从多数节点。比如一份数据在5台设备上有冗余，Quorum算法可以让写操作只要写完3台就返回。剩下的由系统内部缓慢同步完成。而读操作，则需要也至少读3台，才能保证至少可以读到一个最新的数据。

paxos是一种协商共识算法
Paxos 算法将分布式系统中的节点分为三类：
提案节点：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称之为提案（Proposal），值一旦设置成功，就是不会丢失也不可变的。
决策节点：称为 Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被批准。
记录节点：被称为 Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案。
分布式环境中的锁必须是可抢占的。
示例 S1、S2、S3、S4、S5节点，引入随机超时时间来避免活锁的产生。

Multi Paxos 即Raft算法 对 Basic Paxos 的核心改进是增加了“选主”的过程（自动选主），这时候的二元组(id, value)已经变成了三元组(id, i, value)，这是因为需要给主节点增加一个“任期编号”。
主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次心跳包中广播给所有的从节点，并要求从节点回复确认收到的消息，从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送确认签收的消息，主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播可以提交的消息，从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。
通过随机超时来实现无活锁的选主过程，通过主节点来发起写操作，通过心跳来检测存活性，通过Quorum机制来保证一致性。

Gossip 协议：比特币网络中使用到了 Gossip 协议，用它来在各个分布式节点中互相同步区块头和区块体的信息
1 如果有某一项信息需要在整个网络中所有节点中传播，那从信息源开始，选择一个固定的传播周期（譬如 1 秒），随机选择它相连接的 k 个节点（称为 Fan-Out）来传播消息。
2 每一个节点收到消息后，如果这个消息是它之前没有收到过的，将在下一个周期内，选择除了发送消息给它的那个节点外的其他相邻 k 个节点发送相同的消息，直到最终网络中所有节点都收到了消息，尽管这个过程需要一定时间，但是理论上最终网络的所有节点都会拥有相同的消息。

服务注册（添加到列表）、维护（将无效的 服务剔除列表）、发现（消费者从列表中找到精确接口地址）、负载均衡、流量管控
服务发现注册中心：1 在分布式 K/V 存储框架上自己开发的服务发现，这类的代表是 ZooKeeper、Doozerd、Etcd 2 专门用于服务发现的框架和工具，这类的代表是 Eureka、Consul 和 Nacos2 
网关 = 路由器（基础职能） + 过滤器（可选职能）

容错设计模式：
断路器模式（熔断）

流量控制
每秒事务数（Transactions per Second，TPS）每秒请求数（Hits per Second，HPS）每秒查询数（Queries per Second，QPS）
限流设计模式：滑动时间窗模式、漏桶模式、令牌桶模式。

RPC
客户端->请求数据序列化->网络->请求数据反序列化->服务器函数调用->响应数据序列化->网络->响应数据反序列化->服务器端

Kubernetes Master → kubelet → KubeGenericRuntimeManager → DockerShim → Docker Engine → containerd → runC
Kubernetes Master → kubelet → KubeGenericRuntimeManager → containerd → runC

分布式锁实现方式：
mysql: 创建一张锁表，添加锁：insert into methodLock(method_name,cust_id) values (‘method_name’,‘cust_id’)；释放锁：delete from methodLock where method_name ='method_name' and cust_id = 'cust_id' 重入锁判断：select 1 from methodLock where method_name ='method_name' and cust_id = 'cust_id'
设置一个定时处理, 定期清理过期锁
zookeeper