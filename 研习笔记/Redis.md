redis是单线程的nosql（非关系型数据库），由C语言开发。
字符串、哈希、列表、集合、有序集合、发布订阅、GEO
字符串：计数器、key-value缓存数据、加锁解锁、数据库缓存、缓存session
哈希：hget hset 存储对象、缓存数据库查询结果、购物车
列表：按照插入顺序排序的列表 lpush lpop rpop rpush lrange 用作消息队列、api限流
集合：内部的键值对是无序的、唯一的 sadd smembers sismember spop srem 缓存日活记录，好友、关注、粉丝，数据全局去重，交集、并集、差集
有序集合 zadd zrem zrange zcard zrank 排名，延迟队列

发布/订阅：publish subscribe，Redis无法对消息持久化存储，没有提供消息传输保障
事务：watch multi exec，watch是一个乐观锁。入队期间错误会拒绝执行，执行期间会执行正确的指令，忽略错误的指令，即没有回滚功能。

过期键删除策略：定时删除（创建大量定时器，耗费CPU）、惰性删除（耗费内存）、定期删除（需要制定删除策略）。redis采用LRU（Least Recent Used，淘汰掉最不经常使用的，基于hashmap的双向链表数据结构）
RDB持久化：生成的RDB文件是经过压缩的二进制文件。SAVE BGSAVE（执行时客户端发送的SAVE BGSAVE不会执行，bgrewriteaof在bgsave执行完后执行），SAVE命令由服务器进程执行保存工作，因此会阻塞服务器，BGSAVE由子进程执行保存工作，不会阻塞。因此可以用BGSAVE自动保存：save 600 1，600秒修改一次就保存。
AOF持久化：只追加的方式，保存执行的写命令，AOF文件重写（数据相同，体积更小，bgrewriteaof），appendfsync：aways everysec no

`缓存穿透`，数据库没有的数据，缓存里自然没有。可以约定在一定时间内对返回为空的 Key 值依然进行缓存，接口层增加校验，布隆过滤器（在空间和时间方面都具备巨大优势）
`缓存击穿`，有多个针对数据库存在但不在缓存中的数据的请求同时发送过来。cache miss 后请求DB之前必须先获取分布式锁，设置热点数据永远不过期
`缓存雪崩`，大批不同的数据在短时间内一起失效，导致了这些数据的请求都击穿了缓存到达数据源。随机过期时间，设置热点数据永远不过期
`缓存污染`，双写一致性。指缓存中的数据与真实数据源中的数据不一致的现象。读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。写数据时，先写数据源，然后失效（而不是更新）掉缓存。
发生时：限流、降级
`并发竞争`，分布式事务，分布式锁 zookeeper

Redis分布式锁：加锁$redis->set($key, 1, 'NX', 'EX', $expire) 解锁 键过期或del
api限流: 使用列表lrange，rpush存入时间，lpop弹出超时 事务的watch multi
消息队列：rpush生产消息，lpop消费消息。

Redis是基于内存采用单进程单线程的KV数据库，C语言编写。绝大部分操作都是在内存中操作，速度很快。并且它的数据结构是专门进行设计的。
避免了上下文切换和竞争条件（加锁解锁）

redis集群：主从，哨兵，cluster
主从：主服务器写，从服务器读，主从同步（PSYNC两种模式 1 完整同步，初次复制，RDB。2 增量同步，断线后复制的情况）
哨兵：Sentinel，是redis高可用的解决方案，由一个或多个sentinel组成sentinel系统，可以监控任意多个主从服务器，当某个主服务器A下线时，会将其中一个从服务器B（优先级最高->复制偏移量最大）升级为主服务器,并向其它从服务器发送slaveof命令，当A重新上线时会降级为B的从服务器。sentinel服务器是特殊的redis服务器，不使用数据库，当一个主服务器下线时，选举一个领头sentinel（选举规则：先到先得，超半数胜出），由这个领头sentinel对下线服务器进行故障转移处理。
cluster：是redis分布式的解决方案。一个redis集群由多个节点组成，一个节点就是一个redis服务器。每个节点都会使用clusterNode数据结构来记录自己和其它节点的状态。给每个节点分配槽（分片），计算键属于哪个槽（将key带入算法得到一个0到多少范围内的整数，类似hash值取模的算法）。节点分为主节点和从节点。可以进行重新分片。复制与故障转移机制与主从和sentinel类似。

redis慢查询日志：记录执行时间超过指定时间的日志。

HashMap的读写时间复杂度都是O(1)

redis线程模型：采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

一致性哈希：hash取模，当数量变化时会对应不上。将服务器使用IP地址或服务器名哈希后,对2^32取模，形成一个Hash环，再将数据key使用相同的函数哈希取模，沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，对于节点的增减都只需重定位环空间中的一小部分数据。数据倾斜：增加虚拟节点。
布隆过滤器：一个空的布隆过滤器有长度为M比特的bit数组构成，且所有位都初始化0。一个元素通过K个不同的hash函数随机散列到bit数组的K个位置上，K必须远小于M。K和M的大小由错误率（falsepositiverate）决定。布隆过滤器能够准确判断一个元素不在集合内，但只能判断一个元素可能在集合内。
布隆过滤器使用场景：缓存穿透、去重