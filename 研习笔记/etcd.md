# Raft算法
Raft是一种为了管理复制日志的一致性算法。一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障。
**复制状态机** 通常都是基于复制日志实现的，而一致性算法的任务是保证复制日志的一致性。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。因此，服务器集群看起来形成了一个高可靠的状态机。
Raft算法特点：
* 安全性：网络延迟、分区、丢包、重复和乱序等错误都可以保证正确，决不返回一个错误的结果。
* 可用性：只要大多数机器正常，就可以保证可用。

通过领导人的方式，Raft 将一致性问题分解成了三个子问题:
* 领导人选举：领导人故障时，新的领导人要被选举出来。
* 日志复制：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。
* 安全性：日志索引唯一。

**状态转换** 在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者只能响应来自领导人或者候选人的请求。
**任期号** 每个节点存储一个当前任期号，这一编号在整个时期内单调递增。每次服务器之间通信都会交换当前任期号；如果服务器的当前任期号较小，则会更新到较大的任期号值。如果一个候选人或者领导人发现自己的任期号较小，那么他会立即恢复成跟随者状态。
RPC：服务器会并行发起RPC，并会在RPC超时后重试。

**领导人选举**
当服务器程序启动时，他们都是跟随者身份。如果一个跟随者在一段时间里没有接收到领导人或候选人的任何消息，就会增加自己的当前任期号并且转换到候选人状态，发起选举。这时会有三种可能性：
* 当候选人获得超过1/2选票时，就会成为领导人，广播发送心跳。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则。跟随者会拒绝掉已提交日志<=自己的投票请求。Raft通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。
* 在等待投票的时候，候选人可能会收到其它的服务器声明它是领导人的心跳，如果该领导人的任期号>=候选人当前的任期号，那么候选人会回到跟随者状态。
* 瓜分选票。Raft算法使用随机选举超时（从跟随者转换成候选人需要等待的时间）的方法减少选票瓜分的情况，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。

**日志复制**
日志由序号、创建时的任期号、客户端指令组成。
日志条目只从领导人发送给其他的服务器。当客户端指令到来时，领导人把这条指令作为一条新的日志条目附加到日志中，再推送给追随者。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交。当日志提交后，领导人会将该指令应用到状态机。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。
要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。领导人针对每一个跟随者维护了一个nextIndex，当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。领导人从来不会覆盖或者删除自己的日志。

**集群成员变化**：使用共同一致的方法。
当一个领导人接收到一个改变配置从C-old到C-new的请求，会向C-old+C-new的服务器广播C-old+C-new配置，在两种配置上分别获得大多数的支持后提交。
领导人创建一条关于C-new配置的日志条目并复制给集群。
每个服务器在见到新的配置的时候都会立即生效。

**RPC**
服务器会并行发起RPC，并会在RPC超时后重试。Raft 的RPC都应当是幂等的。
**追加条目（AppendEntries）RPC**：

由领导人调用，用于日志条目的复制，同时也被当做心跳使用

| 参数 | 解释 |
| --- | --- |
| term | 领导人的任期 |
| leaderId | 领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人） |
| prevLogIndex | 紧邻新日志条目之前的那个日志条目的索引 |
| prevLogTerm | 紧邻新日志条目之前的那个日志条目的任期 |
| entries\[\] | 需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个） |
| leaderCommit | 领导人的已知已提交的最高的日志条目的索引 |

| 返回值 | 解释 |
| --- | --- |
| term | 当前任期，对于领导人而言 它会更新自己的任期 |
| success | 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true |

接收者的实现：

1.  返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）
2.  返回假 如果接收者日志中没有包含这样一个条目 即该条目的任期在 prevLogIndex 上能和 prevLogTerm 匹配上 （译者注：在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假）
3.  如果一个已经存在的条目和新条目（译者注：即刚刚接收到的日志条目）发生了冲突（因为索引相同，任期不同），那么就删除这个已经存在的条目以及它之后的所有条目
4.  追加日志中尚未存在的任何新条目
5.  如果领导人的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引（`leaderCommit > commitIndex`），则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 领导人的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值

**请求投票（RequestVote）RPC**：

由候选人负责调用用来征集选票

| 参数 | 解释 |
| --- | --- |
| term | 候选人的任期号 |
| candidateId | 请求选票的候选人的 ID |
| lastLogIndex | 候选人的最后日志条目的索引值 |
| lastLogTerm | 候选人最后日志条目的任期号 |

| 返回值 | 解释 |
| --- | --- |
| term | 当前任期号，以便于候选人去更新自己的任期号 |
| voteGranted | 候选人赢得了此张选票时为真 |

接收者实现：

1.  如果`term < currentTerm`返回 false 
2.  如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他
**特性**
所有服务器：
如果commitIndex>lastApplied，则 lastApplied 递增，并将log[lastApplied]应用到状态机中。
如果接收到的RPC请求或响应中，任期号T>currentTerm，则令currentTerm=T，并切换为跟随者状态。

