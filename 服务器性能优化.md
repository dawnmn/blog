#### **慢查询日志**
```
# 配置
vim /etc/my.cnf
slow_query_log=ON
long_query_time=2

# 查看 包括慢日志路径
show variables like '%slow%';
+---------------------------+---------------------------------+
| Variable_name             | Value                           |
+---------------------------+---------------------------------+
| log_slow_admin_statements | OFF                             |
| log_slow_slave_statements | OFF                             |
| slow_launch_time          | 2                               |
| slow_query_log            | ON                              |
| slow_query_log_file       | /var/lib/mysql/dbname-slow.log |
+---------------------------+---------------------------------+
show variables like "%long%";

```

####  **variables & global status**
服务器启动至今的运行数据（重启刷新）
```
# 慢查询
show variables like '%slow%';
show global status like '%slow%';
# 最大连接数
show variables like 'max_connections';
show global status like 'max_used_connections';
# 临时表
show global status like 'created_tmp%';
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Created_tmp_disk_tables | 75512  |
| Created_tmp_files       | 60     |
| Created_tmp_tables      | 365050 |
+-------------------------+--------+
Created_tmp_disk_tables / Created_tmp_tables * 100% ＝ 99% （理想值<= 25%）
# 查询缓存
show variables like 'query_cache%';
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 1048576 |
| query_cache_type             | OFF     |
| query_cache_wlock_invalidate | OFF     |
+------------------------------+---------+
show global status like 'qcache%';
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| Qcache_free_blocks      | 1       |
| Qcache_free_memory      | 1031832 |
| Qcache_hits             | 0       |
| Qcache_inserts          | 0       |
| Qcache_lowmem_prunes    | 0       |
| Qcache_not_cached       | 628800  |
| Qcache_queries_in_cache | 0       |
| Qcache_total_blocks     | 1       |
+-------------------------+---------+
查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100% 
如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。 
查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100% 
查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes > 50的话说明query_cache_size可能有点小，要不就是碎片太多。 
查询缓存命中率 = (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%

查询缓存命中规则：
* 精确地使用客户端传来的查询语句和其他数据。只要字符大小写、空格或者注释有一点点不同，查询缓存就认为这是一个不同的查询。
* 查询缓存不会存储有不确定结果的查询。

查询缓存额外的资源消耗：
* 检查、更新、存储、删除缓存的开销。
* 如果一个表被更改了，那么使用那个表的所有缓冲查询将不再有效。
* 事务会影响缓存。

查询缓存使用建议： 
* 读多写少开启，并进行调优。
* 频繁写直接关闭查询缓存。

# 排序
show variables like 'max_length_for_sort_data';
show variables like 'sort_buffer_size';

排序过程：
1. 根据索引或者全表扫描，按照过滤条件获得需要查询的排序字段值与[rowID/用户需要返回的字段]组成键值对，并存入sort buffer中。
2. 如果sort buffer内存小于这些键值对的内存，就只在内存中排序，否则就需要创建临时文件。
3. 如果不指定order by，mysql会以“最快”的速度进行排序，因此结果是不确定、变化的。

优化排序的方式：
* 排序和查询的字段尽量少。只查询你用到的字段，不要使用select *；使用Limit查询必要的行数据；
* 要排序或者查询的字段，尽量不要用不确定字符函数，避免MySQL直接分配max_sort_length，导致sort buffer空间不足。
* 使用索引来优化或者避免排序。
* 增加sort_buffer_size大小，避免磁盘排序。
* 加大max_length_for_sort_data大小，避免选择老式的算法。
```

#### **数据类型**
更小的通常更好，不仅能节省磁盘，更能够节省内存。
整数类型的unsigned属性可以使正数的上限提高一倍。
IPv4实际上是32位无符号整数，可以使用MySQL的inet_aton()、inet_ntoa()转换。
MySQL的NULL读写都对应PHP的NULL。
更快地读，更慢地写：为了提升读查询的速度，经常需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表，这对于设计高性能数据库是常见的技巧。

#### **索引**
索引优化应该是对查询优化最有效的手段了。“最优”的索引有时候比“好的”索引性能要好几个数量级，创建一个真正“最优”的索引经常需要重写查询。
覆盖索引：select的数据列只用从索引中就能够取得。
回表：从表中查询列值。

#### **查询优化**
最简单衡量查询优化开销的的三个指标：
* 响应时间
* 扫描的行数
* 返回的行数

慢查询方法：
1 访问了太多的行或列
2 扫描的行数和返回的行数
3 






















