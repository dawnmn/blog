`IPC` `RPC` `SOA` `DFS`

**微服务**是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。

**ACID** 原子性（Atomic）一致性（Consistency）隔离性（Isolation）持久性（Durability）
**MySQL事务隔离级别**
| 级别 | symbol | 值 | 描述 |
| --- | --- | --- | --- |
| 读未提交 | READ-UNCOMMITTED | 0 | 存在脏读、不可重复读、幻读的问题 |
| 读已提交 | READ-COMMITTED | 1 | 解决脏读的问题，存在不可重复读、幻读的问题。使用 MMVC机制 |
| 可重复读 | REPEATABLE-READ | 2 | mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MMVC机制 |
| 序列化 | SERIALIZABLE | 3 | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

RR级别下防止幻读，加行锁
```
SELECT `id` FROM `users` WHERE `id` = 1 FOR UPDATE;
```

**MVCC 多版本并发控制** 可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

在 InnoDB 中，我们可以通过行记录的`隐藏列`知道创建该行记录的事务 ID，通过 `undo log` 得到行记录的历史版本，通过` read view` 得到创建 read view 时已经提交了的事务。

在 InnoDB 中，行记录存在三个隐藏列，其中两个是`DATA_TRX_ID`、`DATA_ROLL_PTR`，另一个是`ROW_ID`，当表中没有主键或非空唯一键时存在。

DATA_TRX_ID, 表示该行记录的事务 ID，在 InnoDB 中，修改一个行记录时，会创建一个新的记录并设置事务 ID，同时在 undo log 中保存旧的记录，这时，新纪录的 DATA_ROLL_PTR 会指向 undo log 中的记录，同时，undo log 中的记录也存在执行旧记录的 DATA_ROLL_PTR 指针。

`read view` 是在 SQL 语句执行之前创建的，在 read view 中会保存：
*   `low_limit_id`\- 创建read view时尚未提交的事务中的最大的事务 ID
*   `up_limit_id`\- 创建read view时尚未提交的事务中的最小的事务 ID
*   `trx_ids`\- 创建read view时尚未提交的事务列表

对于 RC 级别来说，我们只需要在每次只需 SELECT 语句是创建 read view 就可以知道已提交的事务列表，从而达到读 已提交 的要求。

对于 RR 级别来说，就只能在事务开始之前创建 read view，在创建事务后提交的数据对于当前事务来说都是不可见的。


**MySQL日志**是 MySQL 数据库的重要组成部分，包括错误日志、查询日志、慢查询日志，二进制日志( `binlog` )和事务日志(`redo log` 和 `undo log` )



