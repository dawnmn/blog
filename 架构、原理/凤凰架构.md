`IPC` `RPC` `SOA` `DFS`

**微服务**是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。

**ACID** 原子性（Atomic）一致性（Consistency）隔离性（Isolation）持久性（Durability）
**MySQL事务隔离级别**
| 级别 | symbol | 值 | 描述 |
| --- | --- | --- | --- |
| 读未提交 | READ-UNCOMMITTED | 0 | 存在脏读、不可重复读、幻读的问题 |
| 读已提交 | READ-COMMITTED | 1 | 解决脏读的问题，存在不可重复读、幻读的问题。使用 MMVC机制 |
| 可重复读 | REPEATABLE-READ | 2 | mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MMVC机制 |
| 序列化 | SERIALIZABLE | 3 | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

RR级别下防止幻读，加行锁
```
SELECT `id` FROM `users` WHERE `id` = 1 FOR UPDATE;
```

**MVCC 多版本并发控制** 可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

在 InnoDB 中，我们可以通过行记录的`隐藏列`知道创建该行记录的事务 ID，通过 `undo log` 得到行记录的历史版本，通过` read view` 得到创建 read view 时已经提交了的事务。

在 InnoDB 中，行记录存在三个隐藏列，其中两个是`DATA_TRX_ID`、`DATA_ROLL_PTR`，另一个是`ROW_ID`，当表中没有主键或非空唯一键时存在。

DATA_TRX_ID, 表示该行记录的事务 ID，是一个全局严格递增的数值。在 InnoDB 中，修改一个行记录时，会创建一个新的记录并设置事务 ID，同时在 undo log 中保存旧的记录，这时，新纪录的 DATA_ROLL_PTR 会指向 undo log 中的记录，同时，undo log 中的记录也存在执行旧记录的 DATA_ROLL_PTR 指针。

`read view` 是在 SQL 语句执行之前创建的，在 read view 中会保存：
*   `low_limit_id`\- 创建read view时尚未提交的事务中的最大的事务 ID
*   `up_limit_id`\- 创建read view时尚未提交的事务中的最小的事务 ID
*   `trx_ids`\- 创建read view时尚未提交的事务列表

对于 RC 级别来说，我们只需要在每次只需 SELECT 语句是创建 read view 就可以知道已提交的事务列表，从而达到读 已提交 的要求。

对于 RR 级别来说，就只能在事务开始之前创建 read view，在创建事务后提交的数据对于当前事务来说都是不可见的。


**MySQL日志**是 MySQL 数据库的重要组成部分，包括错误日志、查询日志、慢查询日志，二进制日志( `binlog` )和事务日志(`redo log` 和 `undo log` )

`binlog` 逻辑日志，用于记录数据库执行的写入性操作(记录哪条数据被修改了，不包括查询)信息，以二进制的形式保存在磁盘中。使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。binlog 是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个 binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。
binlog 的主要使用场景有两个，分别是 `主从复制` 和 `数据恢复 `。
`redo log` 物理日志，实现持久性，只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态 。
![](../images/大小固定，循环写入.png)

|   |redo log | binlog |
| --- | --- |--- |
| 文件大小 | `redo log`的大小是固定的。 | `binlog`可通过配置参数`max_binlog_size`设置每个`binlog`文件的大小。 |
| 实现方式 | `redo log`是`InnoDB`引擎层实现的，并不是所有引擎都有。 | `binlog`是`Server`层实现的，所有引擎都可以使用`binlog`日志 |
| 记录方式 | redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。 | binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 |
| 适用场景 | `redo log`适用于崩溃恢复(crash-safe) | `binlog`适用于主从复制和数据恢复 |

`undo log` 实现`原子性`，同一事务中的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。用于`回滚`和`MVCC`。
`隔离性`，通过加锁实现。InnoDB引擎对update,delete,insert会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。如果加排他锁可以使用`select ... for update` 语句，加共享锁可以使用`select ... lock in share mode`语句。
**全局事务**，XA
`两段式提交`（2 Phase Commit，2PC）协议，分为`准备阶段`，`提交阶段`

**分布式事务**
**CAP**
* 一致性（Consistency）代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。
* 可用性（Availability）代表系统不间断地提供服务的能力。
* 分区容忍性（Partition Tolerance）代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。

**可靠事件队列** 需要具备幂等性，可靠消息队列缺乏隔离性。
![](../images/可靠事件队列.jpg)

**TCC 事务** 是另一种常见的分布式事务机制，它是`Try-Confirm-Cancel`三个单词的缩写,具有较强的隔离性,避免了“超售”的问题。
* Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）(需用到的业务数据设置为“冻结”状态)。
* Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。
* Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。

![](../images/TCC事务.jpg)

**DNS** Domain Name System 域名系统






