只有简洁的设计，才能让软件持久的净化
Go语言特性：拥有自动垃圾回收、包系统、只读的UTF8字符串。
创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。
Go语言自身语法+标准库+mod库
Go是编译型语言，PHP是解释型语言

main函数是整个程序的入口

用形如s[m:n]的形式来获取到一个slice的子集，包括m元素，但不包括n元素，包含n-m个元素
os.Args[0]是可执行文件的完整路径

bufio.NewScanner Scan() Text()方式有每行最大缓存65535的问题，用NewReader的ReadString('\n')，io.EOF的时候读取最后一行。

go会对map里面的值自动初始化，比如map[string]int默认为0。
对map进行range循环时，其迭代顺序是不确定的。


go格式化输出动词：%v %+v(打印结构体时，会添加字段名) %#v %t %d %x %o %b %f %c(输出整数对应的Unicode字符) %s %q %T

Go内置库中io.Reader/Writer是比较常用的接口。围绕io.Reader/Writer，Go语言中有几个常用的实现：
net.Conn, os.Stdin, os.File: 网络、标准输入输出、文件的流读取
strings.Reader: 把字符串抽象成Reader
bytes.Reader: 把[]byte抽象成Reader
bytes.Buffer: 把[]byte抽象成Reader和Writer
bufio.Reader/Writer: 抽象成带缓冲的流读取（比如按行读写）

Go语言中文件读写主要涉及到4个包：io os bufio ioutil
bufio:
```
bufio.NewReader
bufio.NewWriter
bufio.NewScanner
bufio.NewReadWriter

reader.ReadRune() (r rune, size int, err error)
reader.ReadLine()
reader.ReadByte()
reader.ReadBytes(delim byte)
reader.ReadString(delim byte)
reader.ReadSlice(delim byte)
```

io:
```
Reader Writer Closer ReadWriteCloser
io.copy()
```

os: 
```
func OpenFile(name string, flag int, perm FileMode) (*File, error)
func Open(name string) (*File, error)
func Create(name string) (*File, error)
File.Read([]byte) File.ReadAt([]byte, int64) File.Write([]byte) File.WriteString(string) File.WriteAt([]byte, int64)
func Exit(code int)
func Getenv(key string) string
func Getwd() (dir string, err error)
func Hostname() (name string, err error)
func IsExist(err error) bool
func IsNotExist(err error) bool
func IsPathSeparator(c uint8) bool
func IsPermission(err error) bool
func Link(oldname, newname string) error
func LookupEnv(key string) (string, bool)
func Mkdir(name string, perm FileMode) error
func MkdirAll(path string, perm FileMode) error
func Readlink(name string) (string, error)
func Remove(name string) error
func RemoveAll(path string) error
func Rename(oldpath, newpath string) error
func SameFile(fi1, fi2 FileInfo) bool
func Setenv(key, value string) error
func Symlink(oldname, newname string) error
func TempDir() string
func Unsetenv(key string) error
```

ioutil:
```
func ReadAll(r io.Reader) ([]byte, error)
func ReadFile(filename string) ([]byte, error)
func WriteFile(filename string, data []byte, perm os.FileMode) error
func ReadDir(dirname string) ([]os.FileInfo, error)
func TempFile(dir, pattern string) (f *os.File, err error)
func TempDir(dir, pattern string) (name string, err error)
```

net/http
如果处理器参数为 nil，那么服务器将使用默认的多路复用器DefaultServeMux，服务器每一次接收请求处理时都会另起一个goroutine，因此是并发的。
如果你的请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。只会匹配中最精确的那个一。

Go语言里的switch不需要显式地去在每一个case后写break，语言默认执行完case后的逻辑语句会自 动退出。还可以不带操作对象，默认用true代替。

内建常量: true false iota nil
内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error
内建函数: make len cap new append copy close delete complex real imag panic recover

一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋予一个新的值。
一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。
任何类型的指针的零值都是nil。只有当它们指向同一个变量或全部是nil时才相等。
每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。
不同类型的指针不能互相转化，指针变量不能进行运算。

flag示例：
```
var name string
var age int
flag.StringVar(&name, "name", "", "名字")
flag.IntVar(&age, "age", 0, "年龄")
work := flag.Bool("work", false, "是否就业")

flag.Parse()
fmt.Printf("名字：%s 年龄：%d 是否就业：%t, %#v, %d, %d ", name, age, *work, flag.Args(), flag.NArg(), flag.NFlag())
// go run main.go -name=小明 -age=12 -work=false money=0
```

表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。new函数类似是一种语法糖。

x, y = y, x

赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为。
不要将作用域（编译时的属性）和生命周期（运行时的概念）混为一谈。
语法块是由花括弧所包含的一系列语句，语法块内部声明的名字是无法被外部语法块访问的。内部声明会屏蔽外部同名的声明，列如函数中f, err := os.Open(fname)可能会屏蔽外部的f，解决方法是var err

Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础类型： 数字、字符串和布尔型
复合数据类型：数组、结构体
引用类型：指针、切片、字典、函数、通道
接口类型：interface

Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
Go浮点计算存在精度丢失。
布尔值并不会隐式转换为数字值0或1，反之亦然。
文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。字符串的值是不可变的，s[0] = 'L' // compile error。不变性意味如果两个字符串共享相同的底层数据的话也是安全的。
原生字符使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行。被广泛应用于正则表达式、HTML模板、JSON面值等。
```
s := "Hello, 世界" 
fmt.Println(len(s)) // "13" 
fmt.Println(utf8.RuneCountInString(s)) // "9"
```

标准库中字符串处理：bytes、strings、strconv和unicode包
unicode：
```
unicode.IsLetter('a')
unicode.IsLetter(97)
unicode.IsLower(r rune) bool
unicode.IsUpper(r rune) bool
unicode.IsNumber(r rune) bool
unicode.ToLower(r rune) rune
unicode.ToUpper(r rune) rune
utf8.RuneCountInString(string) int
```


bytes：实现了与strings相对应的函数，buffer
方法	说明
var b bytes.Buffer	直接定义一个Buffer变量，不用初始化，可以直接使用
b := new(bytes.Buffer)	使用New返回Buffer变量
b := bytes.NewBuffer(s []byte)	从一个[]byte切片，构造一个Buffer
b := bytes.NewBufferString(s string)	从一个string变量，构造一个Buffer

方法	说明
b.Write(d []byte)	将切片d写入Buffer数据
b.WriteString(s string)	将字符串s写入Buffer尾部
b.WriteByte(c byte)	将字符c写入Buffer尾部
b.WriteRune(r rune)	将一个rune类型的数据放到缓冲器的尾部
b.WriteTo(w io.Writer)	将Buffer中的内容输出到实现了io.Writer接口的可写入对象中
c := make([]byte, 8)
方法	说明
b.Read(c)	一次读取8个byte到c容器中，每次读取新的8个byte覆盖c中原来的内容
b.ReadByte()	读取第一个byte，b的第一个byte被拿掉，赋值给 a => a, _ := b.ReadByte()
b.ReadRune()	读取第一个rune，b的第一个rune被拿掉，赋值给 r => r, _ := b.ReadRune()
b.ReadBytes(delimiter byte)	需要一个byte作为分隔符，读的时候从缓冲器里找第一个出现的分隔符（delim），找到后，把从缓冲器头部开始到分隔符之间的所有byte进行返回，作为byte类型的slice，返回后，缓冲器也会空掉一部分
b.ReadString(delimiter byte)	需要一个byte作为分隔符，读的时候从缓冲器里找第一个出现的分隔符（delim），找到后，把从缓冲器头部开始到分隔符之间的所有byte进行返回，作为字符串返回，返回后，缓冲器也会空掉一部分
b.ReadFrom(i io.Reader)	从一个实现io.Reader接口的r，把r里的内容读到缓冲器里，n返回读的数量

strconv:
atoi、itoa、format系列、parse系列


```
x := 123 
y := fmt.Sprintf("%d", x)
strconv.Itoa(x)

x, err := strconv.Atoi("123") // x is an int 
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
```


数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成，每个数组元素都是完全相同的类型，结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。
通过指针来传递数组参数是高效的。
```
numArr := [...]{1,2,3}
strArr := [...]{1: "小明", 2: "小红", 3: "小王"}
```

一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。
指针指向第一个slice元素对应的底层数组元素的地址，slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。
多个slice之间可以共享底层的数据。如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice。
因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。
```
func reverse(arr []int)  {
	for i, j := 0, len(arr) - 1; i<j ;i, j = i+1, j-1{
		arr[i], arr[j] = arr[j], arr[i]
	}
}

var arr1 [2][6]int // 二维数组
var arr2 [][]int // 二维切片

arr := [...]int{1,2,3,4,5}
m := arr[1:3] // 2,3
n := m[:4] // 2,3,4,5
k := arr[1:4] // 2,3,4

make([]T, len, cap)
```
内置的copy函数可以方便地将一个slice复制另一个相同类型的 slice。
```
func appendInt(x []int, y int) []int {
	var z []int
	zlen := len(x) + 1
	if zlen <= cap(x){
		z = x[:zlen]
	}else if cap(x) == 0{
		z = make([]int, 1, 1)
	}else{
		z = make([]int, zlen, cap(x)*2)
		copy(z, x)
	}
	z[len(x)] = y
	return z
}

var x []int 
x = append(x, 1) 
x = append(x, 2, 3) 
x = append(x, 4, 5, 6) 
x = append(x, x...)
```

一个slice可以用来模拟一个stack:
```
stack = append(stack, v) // push v
top := stack[len(stack)-1] // top of stack
stack = stack[:len(stack)-1] // pop

func remove(slice []int, i int) []int { 
	copy(slice[i:], slice[i+1:])
	return slice[:len(slice)-1] 
}
```

哈希表是一个无序的key/value对的集合，其中所有的key都是不同 的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。
Go语言的map中所有的key都有相同的类型，所以的value也有着相同的类型。
```
ages := make(map[string]int)
ages := map[string]int{ "alice": 31, "charlie": 34, }
bob := ages["bob"] // 0 value对应类型的零值
age, ok := ages["bob"]
```
使用内置的delete函数删除map元素，即使这些元素不在map中也不会报错：delete(ages, "alice")

禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。
并发读写要加锁，slice、map都不是并发安全的。slice、map、chan、指针类型的零值是nil（因为是引用类型）。和slice一样，map之间也不能进行相等比较
Map的迭代顺序是不确定的，按序迭代需要借助slice：
```
names := make([]string, 0, len(ages))
for name,_ := range ages{
	names = append(names, name)
}

sort.Strings(names)
for _,name := range names{
	fmt.Println(ages[name])
}
```

可以用map实现类似set的功能。

结构体是一种聚合的数据类型，可以对成员取地址，然后通过指针访问。
```
var employeeOfTheMonth *Employee = &dilbert 
employeeOfTheMonth.Position += " (proactive team player)"
// 相当于下面语句
(*employeeOfTheMonth).Position += " (proactive team player)"

值传递与引用传递的区别：调用函数返回的是值，并不是一个可取地址的变量
func EmployeeByID1(id int) *Employee { /* ... */ }
func EmployeeByID2(id int) Employee { /* ... */ }
EmployeeByID1(id).Salary = 0 // 正确
EmployeeByID2(id).Salary = 0 // 错误
```

一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。但是S类型的结构体可以包含*S指针类型的成员。
你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初 始化结构体中未导出的成员。

外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。
结构体字面值必须遵循形状类型声明时的结构：
```
w = Wheel{Circle{Point{8, 8}, 5}, 20}
```

实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的简介引用被修改。

函数错误处理：返回值增加一个ok或者err。
在Go中，函数被看作第一类值：函数像其他值一样，拥有类型，可以被赋值给 其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。
如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。形参和返回值的变量名不影响函数标识符。

匿名函数捕获迭代变量的陷阱：函数值中记录z的是循环变量的内存地址，而不是循环变量某一时刻的值。
```
var rmdirs []func()
for _, d := range tempDirs() {
	dir := d // 引入局部变量，作为循环变量的副本
	os.MkdirAll(dir, 0755)
	rmdirs = append(rmdirs, func() { os.RemoveAll(dir) })
}
```

可变参数，定义与使用示例：
```
func sum(vals...int) int
sum()
sum(1)
sum(1,2,3,4)
values := []int{1,2,3,4,5}
sum(values...)
```
可变参数函数和以切片作为参数的函数是不同的。

直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反（入栈与出栈）。
被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值。

当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer机制）。不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常。
应当有选择的使用recover。recover会使程序从panic中恢复，导致panic异常的函数栈（包扩recover的函数）不会继续运行，但能正常返回零值。

不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
Go的结构体用组合的方式实现继承的效果。
方法值和方法表达式：当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数"值"，这种函数会将其第一个参数用作接收器，所以可以用通常(不写选择器)的方式来对其进行调用。
Go语言的封装：通过属性和方法首字母大小写实现。

接口类型：只会展示出它们自己的方法。一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
新的接口类型可以通过组合已经有的接口来定义，方法和结构内嵌相似。
type ReadWriter interface { Reader Writer }

error接口：type error interface { Error() string }

类型断言：语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。
类型断言就是将接口类型的值(x)，转换成类型(T)。格式为：x.(T)。
类型断言的必要条件就x是接口类型，非接口类型的x不能做类型断言。
T可以是非接口类型，如果想断言合法，则T必须实现x的接口。
T也可以是接口，则x的动态类型也应该是接口T。
类型断言如果非法，运行时会导致错误，为了避免这种错误，应该总是使用下面的方式来进行类型断言。
```
number,ok :=x.(int)
```

类型开关，断言与switch的配合：
```
switch v.(type) {
	case string:
}
```

channels是协程之间的通信机制。一个channel有发送和接受两个主要操作，都是通信行为。
Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel之行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话讲产生一个零值的数据（每次获取都是零值）。
x, ok := <-ch // 通过ok判断管道是否关闭
不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。关闭一个channels还会触发一个广播机制。
一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。
同步Channels：基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。
串联Channels（管道pipeline）：Channels也可以用于将多个goroutine串联在一起，一个Channels的输出作为下一个Channels的输入。
可以使用range的数据结构：数组 slice map chan
for x := range ch { } // 不会返回零值

如果发送一直快于接收，或者接收一直快于发送，那么额外的缓存并没有任何好处。

基于select的多路复用：每一个case代表一个通信操作(在某个channel上进行发送或者接收)
```
select {
case <-ch2:
case x := <-ch2:
case ch3 <- 100:
case <-time.After(3 * time.Second):
default:
}

ch := make(chan int, 1)
for i := 0; i < 10; i++ {
	select {
	case x := <-ch:
		fmt.Println(x)  // 0,2,4,6,8
	case ch <- i:
	}
}
```

select{} 永远阻塞
os.Exit(0) 退出程序

如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被 select的机会。
当父协程是main协程时，父协程退出，父协程下的所有子协程也会跟着退出。当父协程不是main协程时，父协程退出，父协程下的所有子协程并不会跟着退出。
goroutines泄漏：无缓存的channel容易造成goroutines泄漏，泄漏的goroutines并不会被自动回收。

Go并发协程退出方式（核心：关闭channel会发送广播）：
1 使用for-range
通过关闭channel的方式，range能够感知channel的关闭，适用于协程只从1个channel读取数据时。
2 使用for-select !ok
2.1 如果某个通道关闭后，需要退出协程，直接return即可。
2.2 如果某个通道关闭了，还继续处理其他case，将该通道置为nil。select不会在nil的通道上进行等待。
3 使用for-select 退出通道
使用一个专门的通道，显式关闭通道可以处理主动通知协程退出。
4 使用for-select context
为每个子协程传递相同的上下文ctx即可，调用cancel()函数后该Context控制的所有子协程都会退出。

我们使用了一个buffered channel作为一个计数信号量，来保证最多只有20个goroutine会同时执行HTTP请求。同理，我们可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。

```
var mu sync.Mutex
mu.Lock()
mu.Unlock()

var mu2 sync.RWMutex
mu2.RLock()
mu2.RUnlock()
mu2.WLock()
mu2.WUnlock()

sync.Map 可以实现单例模式
sync.WaitGroup Add() Done() Wait()
```

内存同步：如果是多个goroutine都需要访问的变量，使用互斥条件来访问。

sync.Once初始化，一个once的Do(func)只会执行一次，即使func变化。

runtime
Gosched() // 让当前线程让出cpu以让其它线程运行，它不会挂起当前线程，因此当前线程未来会继续执行。
Goexit()：退出当前 goroutine（但是defer语句会照常执行）。

Go程序初始化顺序：
导入包，当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来，然后创建和初始化这个包的常量和变量。然后就是调用包里的init函数，如果一个包有多个init函数的话，实现可能是以文件名的顺序调用，同一个文件内的多个init则是以出现的顺序依次调用（init不是普通函数，可以定义有多个，所以不能被其它函数调用）。最终，在main包的所有包常量、包变量被创建和初始化，并且init函数被执行后，才会进入main.main函数，程序开始正常执行。

不要通过共享内存来通信，而应通过通信来共享内存。

通过协程和管道可以实现生产者/消费者、发布/订阅

在Go1.7发布时，标准库增加了一个context包，Context有两个主要的功能：
1 通知子协程退出（正常退出，超时退出等）。context.WithCancel context.WithTimeout context.WithDeadline。当一个Context对象被取消时，继承自它的所有Context都会被取消。
2 传递必要的参数。context.WithValue
以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位。Context是线程安全的。
Done() 返回一个只读channel
background 通常用在 main 函数中，作为所有 context 的根节点。todo 通常用在并不知道传递什么 context的情形。这实际上是空的context，永远不会被cancel。
goroutine的创建是树状结构的，context也是一个树状结构。

```
type Options struct{ Interval time.Duration }
func reqTask(ctx context.Context, name string) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("stop", name)
			return
		default:
			fmt.Println(name, "send request")
			op := ctx.Value("options").(*Options)
			time.Sleep(op.Interval * time.Second)
		}
	}
}
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	vCtx := context.WithValue(ctx, "options", &Options{1})

	go reqTask(vCtx, "worker1")
	go reqTask(vCtx, "worker2")

	time.Sleep(3 * time.Second)
	cancel()
	time.Sleep(3 * time.Second)
}
```





